# Phase 4: Message Type Generation via colcon-cargo-ros2

**Status: PLANNING**

## Overview

Fork `colcon-cargo-ros2` to add a nano-ros backend that generates pure Rust message
types (heapless, no_std) instead of rclrs types (C FFI, std).

**Repository:** `external/colcon-cargo-ros2` (fork maintained alongside nano-ros)

---

## 1. Goal

Enable this workflow:
```bash
# Build with nano-ros backend
ROSIDL_BACKEND=nano-ros colcon build --packages-select my_robot_pkg

# Generated types use nano-ros instead of rclrs
# No C library dependencies, no_std compatible
```

---

## 2. Architecture

### 2.1 Current Flow (rclrs)

```
.msg/.srv files
    ↓
[rosidl-parser] Parse to AST
    ↓
[rosidl-codegen] Askama templates → Two-layer output
    ├── *_rmw.rs      (#[repr(C)], C FFI)
    └── *_idiomatic.rs (Rust wrappers)
    ↓
[rosidl-bindgen] Write to build/<pkg>/rosidl_cargo/
    ↓
Generated Cargo.toml depends on rosidl_runtime_rs + C libs
```

### 2.2 Target Flow (nano-ros)

```
.msg/.srv files
    ↓
[rosidl-parser] Parse to AST (unchanged)
    ↓
[rosidl-codegen] Askama templates → Single-layer output
    └── *.rs (#[derive(RosMessage)], heapless types)
    ↓
[rosidl-bindgen] Write to build/<pkg>/rosidl_cargo/
    ↓
Generated Cargo.toml depends on nano-ros only
```

---

## 3. Implementation Plan

### 3.1 Add Backend Selection

**In `cargo-ros2/src/lib.rs`:**
```rust
#[pyclass]
#[derive(Clone)]
pub enum CodegenBackend {
    Rclrs,    // Current behavior
    NanoRos,  // New nano-ros backend
}

#[pyclass]
pub struct BindgenConfig {
    pub package_name: String,
    pub package_path: Option<PathBuf>,
    pub output_dir: PathBuf,
    pub backend: CodegenBackend,  // Add this
    pub verbose: bool,
}
```

**In Python plugin (`workspace_bindgen.py`):**
```python
backend = os.environ.get('ROSIDL_BACKEND', 'rclrs')
config = BindgenConfig(
    package_name=pkg_name,
    output_dir=output_dir,
    backend=backend,
    ...
)
```

### 3.2 Create nano-ros Templates

Add to `rosidl-codegen/templates/`:

| Template | Purpose |
|----------|---------|
| `message_nano.rs.askama` | Single-layer message struct |
| `service_nano.rs.askama` | Request/Response + service trait |
| `cargo_nano.toml.askama` | nano-ros dependency, no C linking |
| `lib_nano.rs.askama` | Simplified module structure |

### 3.3 Add nano-ros Type Mapping

**In `rosidl-codegen/src/types.rs`:**
```rust
pub fn nano_ros_type(field: &Field) -> String {
    match &field.kind {
        FieldKind::Primitive(p) => primitive_type(p),
        FieldKind::UnboundedString => "heapless::String<256>".into(),
        FieldKind::BoundedString(n) => format!("heapless::String<{n}>"),
        FieldKind::UnboundedSequence(elem) =>
            format!("heapless::Vec<{}, 64>", nano_ros_type(elem)),
        FieldKind::BoundedSequence(elem, n) =>
            format!("heapless::Vec<{}, {n}>", nano_ros_type(elem)),
        FieldKind::Array(elem, n) =>
            format!("[{}; {n}]", nano_ros_type(elem)),
        FieldKind::NestedMessage(pkg, name) =>
            format!("{pkg}::msg::{name}"),
    }
}
```

### 3.4 Modify Code Generation

**In `rosidl-codegen/src/generator.rs`:**
```rust
pub fn generate_message_package(
    package_name: &str,
    message_name: &str,
    message: &Message,
    dependencies: &HashSet<String>,
    backend: CodegenBackend,  // Add parameter
) -> Result<GeneratedPackage> {
    match backend {
        CodegenBackend::Rclrs => generate_rclrs_message(...),
        CodegenBackend::NanoRos => generate_nano_ros_message(...),
    }
}
```

---

## 4. Type Mapping

### 4.1 Primitives (unchanged)

| ROS | Rust |
|-----|------|
| `bool` | `bool` |
| `int8`/`uint8` | `i8`/`u8` |
| `int16`/`uint16` | `i16`/`u16` |
| `int32`/`uint32` | `i32`/`u32` |
| `int64`/`uint64` | `i64`/`u64` |
| `float32`/`float64` | `f32`/`f64` |

### 4.2 Strings

| ROS | rclrs | nano-ros |
|-----|-------|----------|
| `string` | `rosidl_runtime_rs::String` | `heapless::String<256>` |
| `string<=N` | `BoundedString<N>` | `heapless::String<N>` |

### 4.3 Sequences

| ROS | rclrs | nano-ros |
|-----|-------|----------|
| `T[]` | `Sequence<T>` | `heapless::Vec<T, 64>` |
| `T[<=N]` | `BoundedSequence<T, N>` | `heapless::Vec<T, N>` |
| `T[N]` | `[T; N]` | `[T; N]` |

### 4.4 Default Capacities

Unbounded types use configurable defaults:
- Strings: 256 bytes
- Sequences: 64 elements

Future: Allow configuration via `Cargo.toml` metadata or environment variables.

---

## 5. Template Examples

### 5.1 message_nano.rs.askama

```jinja
//! Auto-generated by colcon-cargo-ros2 (nano-ros backend)
//! Package: {{ package_name }}
//! Message: {{ message_name }}

use nano_ros::derive::RosMessage;
{% if has_heapless_types %}
use heapless::{String, Vec};
{% endif %}

{% for constant in constants %}
pub const {{ constant.name }}: {{ constant.rust_type }} = {{ constant.value }};
{% endfor %}

#[derive(Debug, Clone, Default, PartialEq, RosMessage)]
#[ros(package = "{{ package_name }}", name = "{{ message_name }}")]
#[ros(type_name = "{{ package_name }}::msg::dds_::{{ message_name }}_")]
pub struct {{ struct_name }} {
{% for field in fields %}
    pub {{ field.name }}: {{ field.rust_type }},
{% endfor %}
}
```

### 5.2 cargo_nano.toml.askama

```jinja
[package]
name = "{{ package_name }}"
version = "0.1.0"
edition = "2021"

[lib]
path = "src/lib.rs"

[dependencies]
nano-ros = "0.1"
heapless = "0.8"
{% for dep in dependencies %}
{{ dep }} = "0.1"
{% endfor %}

[features]
default = ["std"]
std = ["nano-ros/std"]
```

No `build.rs` - no C library linking needed.

---

## 6. Work Items

### 6.1 Setup
- [ ] Create fork branch in `external/colcon-cargo-ros2`
- [ ] Add `CodegenBackend` enum
- [ ] Thread backend through API (BindgenConfig → generator)

### 6.2 Templates
- [ ] Create `message_nano.rs.askama`
- [ ] Create `service_nano.rs.askama`
- [ ] Create `cargo_nano.toml.askama`
- [ ] Create `lib_nano.rs.askama`
- [ ] Update `askama.toml` to include new templates

### 6.3 Type Mapping
- [ ] Add `nano_ros_type()` function
- [ ] Handle all FieldKind variants
- [ ] Add heapless import detection

### 6.4 Generator
- [ ] Add `generate_nano_ros_message()`
- [ ] Add `generate_nano_ros_service()`
- [ ] Wire up backend selection in generator.rs

### 6.5 Python Integration
- [ ] Expose backend in PyO3 bindings
- [ ] Add `ROSIDL_BACKEND` environment variable support
- [ ] Update `workspace_bindgen.py`

### 6.6 Testing
- [ ] Generate `std_msgs` with nano-ros backend
- [ ] Generate `geometry_msgs` (nested types)
- [ ] Generate `rcl_interfaces` (for parameters)
- [ ] Verify CDR wire compatibility
- [ ] Test interop with ROS 2

### 6.7 Example Applications
- [ ] Create `examples/native-rs-custom-msg/` - Custom message definition and usage
  - Define a custom .msg file in the example
  - Generate bindings using `cargo nano-ros generate`
  - Demonstrate pub/sub with custom message type
  - Test interop with ROS 2 custom message

---

## 7. Generated Output Comparison

### rclrs (current)
```
build/std_msgs/rosidl_cargo/std_msgs/
├── Cargo.toml        # rosidl_runtime_rs + C lib links
├── build.rs          # cargo:rustc-link-lib
└── src/
    └── msg/
        ├── int32_rmw.rs       # #[repr(C)]
        └── int32_idiomatic.rs # Rust wrapper
```

### nano-ros (target)
```
build/std_msgs/rosidl_cargo/std_msgs/
├── Cargo.toml        # nano-ros only
└── src/
    └── msg/
        └── int32.rs  # #[derive(RosMessage)]
```

---

## 8. Success Criteria

- [ ] `ROSIDL_BACKEND=nano-ros colcon build` works
- [ ] Generated types compile without C dependencies
- [ ] Generated types implement `RosMessage` trait
- [ ] CDR serialization matches ROS 2 wire format
- [ ] `std_msgs`, `geometry_msgs`, `rcl_interfaces` generate successfully
- [ ] Interop tests pass (nano-ros ↔ ROS 2)

---

## 9. Dependencies

**Requires:**
- `#[derive(RosMessage)]` macro (Phase 1 - complete)
- nano-ros crate (Phase 3 - complete)

**Enables:**
- `rcl_interfaces` types for parameter services
- Full ROS 2 message ecosystem for nano-ros

---

## 10. References

- [colcon-cargo-ros2](https://github.com/jerry73204/colcon-cargo-ros2)
- [Askama templates](https://djc.github.io/askama/)
- [ROS 2 Interfaces](https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html)
