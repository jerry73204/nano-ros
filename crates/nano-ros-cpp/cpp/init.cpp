/// @file init.cpp
/// @brief Implementation of nano-ros C++ API
///
/// This file implements the C++ wrapper classes that use the cxx-generated
/// FFI bridge to call into the Rust nano-ros implementation.

#include "nano_ros/nano_ros.hpp"

#include <stdexcept>

// Include the cxx runtime header first (provides rust::Error, rust::Box, etc.)
#include "rust/cxx.h"

// Include the cxx-generated bridge header
// This header is generated by cxx-build in the cargo build directory
#include "nano-ros-cpp-bridge/src/lib.rs.h"

namespace nano_ros {

// ============================================================================
// Version functions
// ============================================================================

Version get_version() {
    auto v = ffi::get_version();
    return Version{v.major, v.minor, v.patch};
}

bool has_zenoh_support() {
    return ffi::has_zenoh_support();
}

// ============================================================================
// Context implementation
// ============================================================================

struct Context::Impl {
    ::rust::Box<ffi::RustContext> rust_ctx;

    explicit Impl(::rust::Box<ffi::RustContext> ctx)
        : rust_ctx(std::move(ctx)) {}
};

Context::Context() : impl_(nullptr) {}

Context::~Context() = default;

Context::Context(Context&&) noexcept = default;
Context& Context::operator=(Context&&) noexcept = default;

std::shared_ptr<Context> Context::create() {
    try {
        auto rust_ctx = ffi::create_context();
        auto ctx = std::shared_ptr<Context>(new Context());
        ctx->impl_ = std::make_unique<Impl>(std::move(rust_ctx));
        return ctx;
    } catch (const ::rust::Error& e) {
        throw std::runtime_error(std::string("Failed to create context: ") + e.what());
    }
}

std::shared_ptr<Context> Context::from_env() {
    try {
        auto rust_ctx = ffi::create_context_from_env();
        auto ctx = std::shared_ptr<Context>(new Context());
        ctx->impl_ = std::make_unique<Impl>(std::move(rust_ctx));
        return ctx;
    } catch (const ::rust::Error& e) {
        throw std::runtime_error(std::string("Failed to create context from env: ") + e.what());
    }
}

bool Context::ok() const {
    if (!impl_) return false;
    return ffi::context_ok(*impl_->rust_ctx);
}

uint32_t Context::domain_id() const {
    if (!impl_) return 0;
    return ffi::context_domain_id(*impl_->rust_ctx);
}

std::shared_ptr<Node> Context::create_node(const std::string& name) {
    if (!impl_) {
        throw std::runtime_error("Context is not initialized");
    }
    try {
        auto rust_node = ffi::create_node(*impl_->rust_ctx, name);
        auto node = std::shared_ptr<Node>(new Node());
        node->impl_ = std::make_unique<Node::Impl>(std::move(rust_node));
        return node;
    } catch (const ::rust::Error& e) {
        throw std::runtime_error(std::string("Failed to create node: ") + e.what());
    }
}

std::shared_ptr<Node> Context::create_node(
    const std::string& name,
    const std::string& ns
) {
    if (!impl_) {
        throw std::runtime_error("Context is not initialized");
    }
    try {
        auto rust_node = ffi::create_node_with_namespace(*impl_->rust_ctx, name, ns);
        auto node = std::shared_ptr<Node>(new Node());
        node->impl_ = std::make_unique<Node::Impl>(std::move(rust_node));
        return node;
    } catch (const ::rust::Error& e) {
        throw std::runtime_error(std::string("Failed to create node: ") + e.what());
    }
}

// ============================================================================
// Node implementation
// ============================================================================

struct Node::Impl {
    ::rust::Box<ffi::RustNode> rust_node;

    explicit Impl(::rust::Box<ffi::RustNode> node)
        : rust_node(std::move(node)) {}
};

Node::Node() : impl_(nullptr) {}

Node::~Node() = default;

Node::Node(Node&&) noexcept = default;
Node& Node::operator=(Node&&) noexcept = default;

std::string Node::get_name() const {
    if (!impl_) return "";
    return std::string(ffi::node_name(*impl_->rust_node));
}

std::string Node::get_namespace() const {
    if (!impl_) return "";
    return std::string(ffi::node_namespace(*impl_->rust_node));
}

std::string Node::get_fully_qualified_name() const {
    if (!impl_) return "";
    return std::string(ffi::node_fully_qualified_name(*impl_->rust_node));
}

} // namespace nano_ros
