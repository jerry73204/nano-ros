//! C++ bindings for nano-ros via cxx
//!
//! This crate provides the FFI bridge between Rust nano-ros and C++ code.
//! The bridge is generated by the `cxx` crate and exposes a subset of the
//! nano-ros API for use from C++.

// Allow deprecated API usage - we intentionally use create_node for C++ bindings
// TODO: Migrate to executor API in Phase 10.6
#![allow(deprecated)]

// Re-import nano-ros types we'll expose
use nano_ros::{Context, InitOptions, Node, NodeOptions};

/// Opaque wrapper for Rust Context
pub struct RustContext {
    inner: Context,
}

/// Opaque wrapper for Rust Node
pub struct RustNode {
    inner: Node,
}

#[cxx::bridge(namespace = "nano_ros::ffi")]
mod ffi {
    /// Version information
    struct VersionInfo {
        major: u32,
        minor: u32,
        patch: u32,
    }

    extern "Rust" {
        // ====================================================================
        // Library info
        // ====================================================================

        /// Get the nano-ros library version
        fn get_version() -> VersionInfo;

        /// Check if the library was built with zenoh support
        fn has_zenoh_support() -> bool;

        // ====================================================================
        // Context
        // ====================================================================

        /// Opaque Rust context type
        type RustContext;

        /// Create a new context with default options
        fn create_context() -> Result<Box<RustContext>>;

        /// Create a context from environment variables
        fn create_context_from_env() -> Result<Box<RustContext>>;

        /// Check if context is valid
        fn context_ok(ctx: &RustContext) -> bool;

        /// Get the domain ID
        fn context_domain_id(ctx: &RustContext) -> u32;

        // ====================================================================
        // Node
        // ====================================================================

        /// Opaque Rust node type
        type RustNode;

        /// Create a node with the given name
        fn create_node(ctx: &RustContext, name: &str) -> Result<Box<RustNode>>;

        /// Create a node with name and namespace
        fn create_node_with_namespace(
            ctx: &RustContext,
            name: &str,
            ns: &str,
        ) -> Result<Box<RustNode>>;

        /// Get the node name
        fn node_name(node: &RustNode) -> String;

        /// Get the node namespace
        fn node_namespace(node: &RustNode) -> String;

        /// Get the fully qualified node name
        fn node_fully_qualified_name(node: &RustNode) -> String;
    }
}

// ============================================================================
// Implementation of FFI functions
// ============================================================================

fn get_version() -> ffi::VersionInfo {
    ffi::VersionInfo {
        major: 0,
        minor: 1,
        patch: 0,
    }
}

fn has_zenoh_support() -> bool {
    true
}

fn create_context() -> Result<Box<RustContext>, String> {
    let options = InitOptions::new();
    match Context::new(options) {
        Ok(ctx) => Ok(Box::new(RustContext { inner: ctx })),
        Err(e) => Err(format!("Failed to create context: {:?}", e)),
    }
}

fn create_context_from_env() -> Result<Box<RustContext>, String> {
    match Context::from_env() {
        Ok(ctx) => Ok(Box::new(RustContext { inner: ctx })),
        Err(e) => Err(format!("Failed to create context from env: {:?}", e)),
    }
}

fn context_ok(ctx: &RustContext) -> bool {
    ctx.inner.ok()
}

fn context_domain_id(ctx: &RustContext) -> u32 {
    ctx.inner.domain_id()
}

fn create_node(ctx: &RustContext, name: &str) -> Result<Box<RustNode>, String> {
    match ctx.inner.create_node(name) {
        Ok(node) => Ok(Box::new(RustNode { inner: node })),
        Err(e) => Err(format!("Failed to create node: {:?}", e)),
    }
}

fn create_node_with_namespace(
    ctx: &RustContext,
    name: &str,
    ns: &str,
) -> Result<Box<RustNode>, String> {
    let options = NodeOptions::new(name).namespace(ns);
    match ctx.inner.create_node(options) {
        Ok(node) => Ok(Box::new(RustNode { inner: node })),
        Err(e) => Err(format!("Failed to create node: {:?}", e)),
    }
}

fn node_name(node: &RustNode) -> String {
    node.inner.name().to_string()
}

fn node_namespace(node: &RustNode) -> String {
    node.inner.namespace().to_string()
}

fn node_fully_qualified_name(node: &RustNode) -> String {
    // fully_qualified_name returns heapless::String, convert to std::String
    let ns = node.inner.namespace();
    let name = node.inner.name();
    if ns == "/" {
        format!("/{}", name)
    } else {
        format!("{}/{}", ns, name)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version() {
        let v = get_version();
        assert_eq!(v.major, 0);
        assert_eq!(v.minor, 1);
        assert_eq!(v.patch, 0);
    }

    #[test]
    fn test_has_zenoh() {
        assert!(has_zenoh_support());
    }
}
