//! CDR format compatibility tests
//!
//! These tests verify that nano-ros-serdes produces byte-identical output to Micro-CDR.
//! Test vectors were generated by analyzing the Micro-CDR implementation.

#[cfg(test)]
mod tests {
    use crate::{CdrReader, CdrWriter, Deserialize, Serialize, CDR_LE_HEADER};

    /// Test that our CDR header matches Pico-ROS/Micro-CDR
    /// Pico-ROS uses: `*((uint32_t*)pBUF) = 0x0100;` which is [0x00, 0x01, 0x00, 0x00]
    #[test]
    fn test_cdr_header_format() {
        let mut buf = [0u8; 8];
        let writer = CdrWriter::new_with_header(&mut buf).unwrap();
        let pos = writer.position();
        drop(writer);

        // Pico-ROS format: 0x0100 as u32 little-endian = [0x00, 0x01, 0x00, 0x00]
        assert_eq!(&buf[0..4], &CDR_LE_HEADER);
        assert_eq!(&buf[0..4], &[0x00, 0x01, 0x00, 0x00]);
        assert_eq!(pos, 4);
    }

    /// Test u8 serialization (no alignment needed)
    #[test]
    fn test_u8_byte_format() {
        let mut buf = [0u8; 8];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            42u8.serialize(&mut writer).unwrap();
            writer.position()
        };

        assert_eq!(buf[0], 42);
        assert_eq!(pos, 1);
    }

    /// Test i8 serialization (no alignment needed)
    #[test]
    fn test_i8_byte_format() {
        let mut buf = [0u8; 8];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            (-42i8).serialize(&mut writer).unwrap();
            writer.position()
        };

        assert_eq!(buf[0], 0xD6); // -42 in two's complement
        assert_eq!(pos, 1);
    }

    /// Test bool serialization (1 byte, 0x00 or 0x01)
    #[test]
    fn test_bool_byte_format() {
        let mut buf = [0u8; 8];

        {
            let mut writer = CdrWriter::new(&mut buf);
            true.serialize(&mut writer).unwrap();
        }
        assert_eq!(buf[0], 0x01);

        {
            let mut writer = CdrWriter::new(&mut buf);
            false.serialize(&mut writer).unwrap();
        }
        assert_eq!(buf[0], 0x00);
    }

    /// Test u16 serialization (2-byte alignment, little-endian)
    #[test]
    fn test_u16_byte_format() {
        let mut buf = [0u8; 8];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            0x1234u16.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Little-endian: low byte first
        assert_eq!(&buf[0..2], &[0x34, 0x12]);
        assert_eq!(pos, 2);
    }

    /// Test u32 serialization (4-byte alignment, little-endian)
    #[test]
    fn test_u32_byte_format() {
        let mut buf = [0u8; 8];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            0x12345678u32.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Little-endian
        assert_eq!(&buf[0..4], &[0x78, 0x56, 0x34, 0x12]);
        assert_eq!(pos, 4);
    }

    /// Test u64 serialization (8-byte alignment, little-endian)
    #[test]
    fn test_u64_byte_format() {
        let mut buf = [0u8; 16];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            0x123456789ABCDEF0u64.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Little-endian
        assert_eq!(
            &buf[0..8],
            &[0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12]
        );
        assert_eq!(pos, 8);
    }

    /// Test f32 serialization (IEEE 754, 4-byte alignment)
    #[test]
    fn test_f32_byte_format() {
        let mut buf = [0u8; 8];
        {
            let mut writer = CdrWriter::new(&mut buf);
            1.0f32.serialize(&mut writer).unwrap();
        }

        // IEEE 754: 1.0f32 = 0x3F800000
        assert_eq!(&buf[0..4], &[0x00, 0x00, 0x80, 0x3F]);
    }

    /// Test f64 serialization (IEEE 754, 8-byte alignment)
    #[test]
    fn test_f64_byte_format() {
        let mut buf = [0u8; 16];
        {
            let mut writer = CdrWriter::new(&mut buf);
            1.0f64.serialize(&mut writer).unwrap();
        }

        // IEEE 754: 1.0f64 = 0x3FF0000000000000
        assert_eq!(
            &buf[0..8],
            &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F]
        );
    }

    /// Test alignment after u8 followed by u32
    /// CDR requires 4-byte alignment for u32
    #[test]
    fn test_alignment_u8_then_u32() {
        let mut buf = [0u8; 16];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            1u8.serialize(&mut writer).unwrap();
            0x12345678u32.serialize(&mut writer).unwrap();
            writer.position()
        };

        // u8 at offset 0, then 3 bytes padding, then u32 at offset 4
        assert_eq!(buf[0], 1); // u8
        assert_eq!(&buf[1..4], &[0, 0, 0]); // padding
        assert_eq!(&buf[4..8], &[0x78, 0x56, 0x34, 0x12]); // u32
        assert_eq!(pos, 8);
    }

    /// Test alignment after u8 followed by u64
    /// CDR requires 8-byte alignment for u64
    #[test]
    fn test_alignment_u8_then_u64() {
        let mut buf = [0u8; 24];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            1u8.serialize(&mut writer).unwrap();
            0x123456789ABCDEF0u64.serialize(&mut writer).unwrap();
            writer.position()
        };

        // u8 at offset 0, then 7 bytes padding, then u64 at offset 8
        assert_eq!(buf[0], 1); // u8
        assert_eq!(&buf[1..8], &[0, 0, 0, 0, 0, 0, 0]); // padding
        assert_eq!(
            &buf[8..16],
            &[0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12]
        );
        assert_eq!(pos, 16);
    }

    /// Test string format: 4-byte length (including null) + data + null terminator
    #[test]
    fn test_string_byte_format() {
        let mut buf = [0u8; 32];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            let s: heapless::String<32> = heapless::String::try_from("Hello").unwrap();
            s.serialize(&mut writer).unwrap();
            writer.position()
        };

        // CDR string: u32 length (6 = 5 chars + null), then "Hello\0"
        assert_eq!(&buf[0..4], &[6, 0, 0, 0]); // length = 6 (little-endian)
        assert_eq!(&buf[4..10], b"Hello\0");
        assert_eq!(pos, 10);
    }

    /// Test empty string format
    #[test]
    fn test_empty_string_byte_format() {
        let mut buf = [0u8; 16];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            let s: heapless::String<32> = heapless::String::new();
            s.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Empty string: length = 1 (just null terminator)
        assert_eq!(&buf[0..4], &[1, 0, 0, 0]); // length = 1
        assert_eq!(buf[4], 0); // null terminator
        assert_eq!(pos, 5);
    }

    /// Test sequence (variable-length array) format
    #[test]
    fn test_sequence_byte_format() {
        let mut buf = [0u8; 32];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            let v: heapless::Vec<u32, 8> = heapless::Vec::from_slice(&[1, 2, 3]).unwrap();
            v.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Sequence: u32 count, then elements
        assert_eq!(&buf[0..4], &[3, 0, 0, 0]); // count = 3
        assert_eq!(&buf[4..8], &[1, 0, 0, 0]); // element 1
        assert_eq!(&buf[8..12], &[2, 0, 0, 0]); // element 2
        assert_eq!(&buf[12..16], &[3, 0, 0, 0]); // element 3
        assert_eq!(pos, 16);
    }

    /// Test fixed-size array format (no length prefix)
    #[test]
    fn test_array_byte_format() {
        let mut buf = [0u8; 16];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);
            let arr: [u32; 3] = [1, 2, 3];
            arr.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Fixed array: no length prefix, just elements
        assert_eq!(&buf[0..4], &[1, 0, 0, 0]); // element 1
        assert_eq!(&buf[4..8], &[2, 0, 0, 0]); // element 2
        assert_eq!(&buf[8..12], &[3, 0, 0, 0]); // element 3
        assert_eq!(pos, 12);
    }

    /// Test complex struct-like serialization (simulating ROS Time)
    /// Time = { sec: i32, nanosec: u32 }
    #[test]
    fn test_time_byte_format() {
        let mut buf = [0u8; 16];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);

            let sec: i32 = 1234567890;
            let nanosec: u32 = 123456789;

            sec.serialize(&mut writer).unwrap();
            nanosec.serialize(&mut writer).unwrap();
            writer.position()
        };

        // sec = 1234567890 = 0x499602D2
        assert_eq!(&buf[0..4], &[0xD2, 0x02, 0x96, 0x49]);
        // nanosec = 123456789 = 0x075BCD15
        assert_eq!(&buf[4..8], &[0x15, 0xCD, 0x5B, 0x07]);
        assert_eq!(pos, 8);
    }

    /// Test geometry_msgs/Point format (3 x f64)
    #[test]
    fn test_point_byte_format() {
        let mut buf = [0u8; 32];
        let pos = {
            let mut writer = CdrWriter::new(&mut buf);

            let x: f64 = 1.0;
            let y: f64 = 2.0;
            let z: f64 = 3.0;

            x.serialize(&mut writer).unwrap();
            y.serialize(&mut writer).unwrap();
            z.serialize(&mut writer).unwrap();
            writer.position()
        };

        // x = 1.0f64 = 0x3FF0000000000000
        assert_eq!(
            &buf[0..8],
            &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F]
        );
        // y = 2.0f64 = 0x4000000000000000
        assert_eq!(
            &buf[8..16],
            &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40]
        );
        // z = 3.0f64 = 0x4008000000000000
        assert_eq!(
            &buf[16..24],
            &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40]
        );
        assert_eq!(pos, 24);
    }

    /// Test with encapsulation header (full CDR message format)
    #[test]
    fn test_full_cdr_message_format() {
        let mut buf = [0u8; 32];
        let pos = {
            let mut writer = CdrWriter::new_with_header(&mut buf).unwrap();
            0x12345678u32.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Header: [0x00, 0x01, 0x00, 0x00]
        assert_eq!(&buf[0..4], &[0x00, 0x01, 0x00, 0x00]);
        // Data: u32 at offset 4 (already aligned)
        assert_eq!(&buf[4..8], &[0x78, 0x56, 0x34, 0x12]);
        assert_eq!(pos, 8);
    }

    /// Test deserialization matches serialization
    #[test]
    fn test_roundtrip_complex() {
        let mut buf = [0u8; 64];

        // Simulate a message with mixed types
        let a: u8 = 0x42;
        let b: u32 = 0x12345678;
        let c: f64 = 3.14159;
        let d: heapless::String<32> = heapless::String::try_from("test").unwrap();

        let len = {
            let mut writer = CdrWriter::new(&mut buf);
            a.serialize(&mut writer).unwrap();
            b.serialize(&mut writer).unwrap();
            c.serialize(&mut writer).unwrap();
            d.serialize(&mut writer).unwrap();
            writer.position()
        };

        // Deserialize
        let mut reader = CdrReader::new(&buf[..len]);
        let a2: u8 = Deserialize::deserialize(&mut reader).unwrap();
        let b2: u32 = Deserialize::deserialize(&mut reader).unwrap();
        let c2: f64 = Deserialize::deserialize(&mut reader).unwrap();
        let d2: heapless::String<32> = Deserialize::deserialize(&mut reader).unwrap();

        assert_eq!(a, a2);
        assert_eq!(b, b2);
        assert_eq!(c, c2);
        assert_eq!(d, d2);
    }

    /// Test that alignment with header works correctly
    /// After 4-byte header, data should be aligned relative to origin
    #[test]
    fn test_alignment_after_header() {
        let mut buf = [0u8; 32];
        {
            let mut writer = CdrWriter::new_with_header(&mut buf).unwrap();
            // Write u8 (1 byte, at offset 4)
            1u8.serialize(&mut writer).unwrap();
            // Write u32 (needs 4-byte alignment from origin)
            // Current position is 5, origin is 4
            // Offset from origin = 1, alignment needed: (4 - (1 % 4)) % 4 = 3
            0x12345678u32.serialize(&mut writer).unwrap();
        }

        assert_eq!(&buf[0..4], &[0x00, 0x01, 0x00, 0x00]); // header
        assert_eq!(buf[4], 1); // u8
        assert_eq!(&buf[5..8], &[0, 0, 0]); // padding
        assert_eq!(&buf[8..12], &[0x78, 0x56, 0x34, 0x12]); // u32
    }

    /// Test negative integers
    #[test]
    fn test_negative_integers() {
        let mut buf = [0u8; 32];
        {
            let mut writer = CdrWriter::new(&mut buf);
            (-1i32).serialize(&mut writer).unwrap();
            (-1i64).serialize(&mut writer).unwrap();
        }

        // -1i32 = 0xFFFFFFFF
        assert_eq!(&buf[0..4], &[0xFF, 0xFF, 0xFF, 0xFF]);
        // -1i64 = 0xFFFFFFFFFFFFFFFF (at offset 8 due to alignment)
        assert_eq!(
            &buf[8..16],
            &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
        );
    }

    /// Test special float values
    #[test]
    fn test_special_floats() {
        let mut buf = [0u8; 32];

        // Test positive zero
        {
            let mut writer = CdrWriter::new(&mut buf);
            0.0f32.serialize(&mut writer).unwrap();
        }
        assert_eq!(&buf[0..4], &[0x00, 0x00, 0x00, 0x00]);

        // Test negative zero
        {
            let mut writer = CdrWriter::new(&mut buf);
            (-0.0f32).serialize(&mut writer).unwrap();
        }
        assert_eq!(&buf[0..4], &[0x00, 0x00, 0x00, 0x80]); // Sign bit set

        // Test infinity
        {
            let mut writer = CdrWriter::new(&mut buf);
            f32::INFINITY.serialize(&mut writer).unwrap();
        }
        assert_eq!(&buf[0..4], &[0x00, 0x00, 0x80, 0x7F]);
    }
}
