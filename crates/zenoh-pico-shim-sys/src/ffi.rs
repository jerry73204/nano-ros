//! FFI declarations for zenoh-pico-shim
//!
//! This module defines the C API that the shim implements and the
//! platform FFI functions that Rust provides.
//!
//! # Header Generation
//!
//! The header `c/include/zenoh_shim.h` is automatically generated by cbindgen
//! during the build process (see `build.rs`).

use core::ffi::c_void;

// c_char is used in cbindgen stubs
#[cfg(cbindgen)]
use core::ffi::c_char;

// ============================================================================
// Configuration Constants
// ============================================================================

/// Maximum number of concurrent publishers
pub const ZENOH_SHIM_MAX_PUBLISHERS: usize = 8;

/// Maximum number of concurrent subscribers
pub const ZENOH_SHIM_MAX_SUBSCRIBERS: usize = 8;

/// Maximum number of concurrent liveliness tokens
pub const ZENOH_SHIM_MAX_LIVELINESS: usize = 16;

/// Maximum number of concurrent queryables
pub const ZENOH_SHIM_MAX_QUERYABLES: usize = 8;

/// Size of Zenoh ID in bytes
pub const ZENOH_SHIM_ZID_SIZE: usize = 16;

/// Size of RMW GID in bytes (for ROS 2 humble compatibility)
pub const ZENOH_SHIM_RMW_GID_SIZE: usize = 16;

// ============================================================================
// Error Codes
// ============================================================================

/// Success
pub const ZENOH_SHIM_OK: i32 = 0;
/// Generic error
pub const ZENOH_SHIM_ERR_GENERIC: i32 = -1;
/// Configuration error
pub const ZENOH_SHIM_ERR_CONFIG: i32 = -2;
/// Session error
pub const ZENOH_SHIM_ERR_SESSION: i32 = -3;
/// Task creation error
pub const ZENOH_SHIM_ERR_TASK: i32 = -4;
/// Invalid key expression
pub const ZENOH_SHIM_ERR_KEYEXPR: i32 = -5;
/// Resource limit reached
pub const ZENOH_SHIM_ERR_FULL: i32 = -6;
/// Invalid handle
pub const ZENOH_SHIM_ERR_INVALID: i32 = -7;
/// Publish error
pub const ZENOH_SHIM_ERR_PUBLISH: i32 = -8;

// ============================================================================
// Callback Types
// ============================================================================

/// Callback function type for receiving samples.
///
/// # Parameters
/// * `data` - Pointer to received data buffer
/// * `len` - Length of data in bytes
/// * `ctx` - User-provided context pointer
pub type ShimCallback = extern "C" fn(data: *const u8, len: usize, ctx: *mut c_void);

/// Callback function type for receiving queries (service requests).
///
/// # Parameters
/// * `keyexpr` - Key expression string (not null-terminated)
/// * `keyexpr_len` - Length of key expression
/// * `payload` - Pointer to request payload (may be NULL)
/// * `payload_len` - Length of payload in bytes
/// * `ctx` - User-provided context pointer
pub type ShimQueryCallback = extern "C" fn(
    keyexpr: *const core::ffi::c_char,
    keyexpr_len: usize,
    payload: *const u8,
    payload_len: usize,
    ctx: *mut c_void,
);

/// C-compatible callback function pointer type
pub type PollCallback = extern "C" fn();

// ============================================================================
// cbindgen Stub Functions for Shim API
//
// These stubs exist only for cbindgen to generate the C header.
// They are never actually called - the C implementation is linked instead.
// ============================================================================

#[cfg(cbindgen)]
mod cbindgen_stubs {
    use super::*;

    /// Initialize zenoh configuration with client mode and connect locator.
    ///
    /// # Parameters
    /// * `locator` - Connection string (e.g., "tcp/192.168.1.1:7447"), null-terminated.
    ///   Can be NULL to use default.
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_init(_locator: *const c_char) -> i32 {
        0
    }

    /// Open zenoh session and start background tasks (if threaded backend).
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_open() -> i32 {
        0
    }

    /// Check if session is currently open.
    ///
    /// # Returns
    /// Non-zero if open, 0 if closed.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_is_open() -> i32 {
        0
    }

    /// Close the session and clean up all resources.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_close() {}

    /// Declare a publisher for the given key expression.
    ///
    /// # Parameters
    /// * `keyexpr` - Key expression string (e.g., "demo/topic"), null-terminated.
    ///
    /// # Returns
    /// Publisher handle (>= 0) on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_declare_publisher(_keyexpr: *const c_char) -> i32 {
        0
    }

    /// Publish data using publisher handle.
    ///
    /// # Parameters
    /// * `handle` - Publisher handle from zenoh_shim_declare_publisher()
    /// * `data` - Pointer to data buffer
    /// * `len` - Length of data in bytes
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_publish(_handle: i32, _data: *const u8, _len: usize) -> i32 {
        0
    }

    /// Undeclare a publisher.
    ///
    /// # Parameters
    /// * `handle` - Publisher handle
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_undeclare_publisher(_handle: i32) -> i32 {
        0
    }

    /// Declare a subscriber for the given key expression.
    ///
    /// # Parameters
    /// * `keyexpr` - Key expression string (e.g., "demo/topic"), null-terminated.
    /// * `callback` - Callback function to invoke when samples arrive
    /// * `ctx` - User context pointer passed to callback
    ///
    /// # Returns
    /// Subscriber handle (>= 0) on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_declare_subscriber(
        _keyexpr: *const c_char,
        _callback: ShimCallback,
        _ctx: *mut c_void,
    ) -> i32 {
        0
    }

    /// Undeclare a subscriber.
    ///
    /// # Parameters
    /// * `handle` - Subscriber handle
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_undeclare_subscriber(_handle: i32) -> i32 {
        0
    }

    /// Poll for incoming data and process callbacks.
    ///
    /// For threaded backends (Zephyr, POSIX), this is a no-op as background
    /// tasks handle polling automatically.
    ///
    /// For polling backends (smoltcp), this must be called regularly to
    /// process network data and dispatch callbacks.
    ///
    /// # Parameters
    /// * `timeout_ms` - Maximum time to wait for data (0 = non-blocking)
    ///
    /// # Returns
    /// Number of events processed, or negative on error.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_poll(_timeout_ms: u32) -> i32 {
        0
    }

    /// Combined poll and keepalive operation.
    ///
    /// This is equivalent to calling zenoh_shim_poll() and performing any
    /// necessary keepalive operations. For threaded backends, this is just
    /// a brief poll. For polling backends, this handles both network I/O
    /// and zenoh protocol maintenance.
    ///
    /// # Parameters
    /// * `timeout_ms` - Maximum time to wait (0 = non-blocking)
    ///
    /// # Returns
    /// Number of events processed, or negative on error.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_spin_once(_timeout_ms: u32) -> i32 {
        0
    }

    /// Check if the current backend uses polling.
    ///
    /// # Returns
    /// true if polling required (smoltcp), false if threaded (Zephyr, POSIX).
    #[no_mangle]
    pub extern "C" fn zenoh_shim_uses_polling() -> bool {
        false
    }

    // ========================================================================
    // ZenohId API
    // ========================================================================

    /// Get the session's Zenoh ID.
    ///
    /// # Parameters
    /// * `zid_out` - Pointer to 16-byte buffer to receive the ZID
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_get_zid(_zid_out: *mut u8) -> i32 {
        0
    }

    // ========================================================================
    // Liveliness API
    // ========================================================================

    /// Declare a liveliness token for ROS 2 discovery.
    ///
    /// # Parameters
    /// * `keyexpr` - Key expression string, null-terminated.
    ///
    /// # Returns
    /// Liveliness handle (>= 0) on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_declare_liveliness(_keyexpr: *const c_char) -> i32 {
        0
    }

    /// Undeclare a liveliness token.
    ///
    /// # Parameters
    /// * `handle` - Liveliness handle
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_undeclare_liveliness(_handle: i32) -> i32 {
        0
    }

    // ========================================================================
    // Publish with Attachment API
    // ========================================================================

    /// Publish data with an attachment (for RMW compatibility).
    ///
    /// # Parameters
    /// * `handle` - Publisher handle
    /// * `data` - Pointer to data buffer
    /// * `len` - Length of data in bytes
    /// * `attachment` - Pointer to attachment buffer (may be NULL)
    /// * `attachment_len` - Length of attachment in bytes
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_publish_with_attachment(
        _handle: i32,
        _data: *const u8,
        _len: usize,
        _attachment: *const u8,
        _attachment_len: usize,
    ) -> i32 {
        0
    }

    // ========================================================================
    // Queryable API (for ROS 2 Services)
    // ========================================================================

    /// Declare a queryable for receiving service requests.
    ///
    /// # Parameters
    /// * `keyexpr` - Key expression string, null-terminated.
    /// * `callback` - Callback function to invoke when queries arrive
    /// * `ctx` - User context pointer passed to callback
    ///
    /// # Returns
    /// Queryable handle (>= 0) on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_declare_queryable(
        _keyexpr: *const c_char,
        _callback: ShimQueryCallback,
        _ctx: *mut c_void,
    ) -> i32 {
        0
    }

    /// Undeclare a queryable.
    ///
    /// # Parameters
    /// * `handle` - Queryable handle
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_undeclare_queryable(_handle: i32) -> i32 {
        0
    }

    /// Reply to a query (must be called within query callback).
    ///
    /// # Parameters
    /// * `keyexpr` - Reply key expression string, null-terminated.
    /// * `data` - Pointer to reply data buffer
    /// * `len` - Length of data in bytes
    /// * `attachment` - Pointer to attachment buffer (may be NULL)
    /// * `attachment_len` - Length of attachment in bytes
    ///
    /// # Returns
    /// 0 on success, negative error code on failure.
    #[no_mangle]
    pub extern "C" fn zenoh_shim_query_reply(
        _keyexpr: *const c_char,
        _data: *const u8,
        _len: usize,
        _attachment: *const u8,
        _attachment_len: usize,
    ) -> i32 {
        0
    }

    // ========================================================================
    // smoltcp Platform FFI Stubs
    //
    // These are called by the C platform layer (system.c, network.c)
    // and implemented in Rust (platform/smoltcp.rs).
    // ========================================================================

    /// Allocate memory
    #[no_mangle]
    pub extern "C" fn smoltcp_alloc(_size: usize) -> *mut c_void {
        core::ptr::null_mut()
    }

    /// Reallocate memory
    ///
    /// Note: This is a simplified implementation that allocates new memory
    /// and copies the data. The old memory is "leaked" (not reused).
    #[no_mangle]
    pub extern "C" fn smoltcp_realloc(_ptr: *mut c_void, _size: usize) -> *mut c_void {
        core::ptr::null_mut()
    }

    /// Free memory (no-op for bump allocator)
    #[no_mangle]
    pub extern "C" fn smoltcp_free(_ptr: *mut c_void) {}

    /// Generate a random u32 using xorshift32
    #[no_mangle]
    pub extern "C" fn smoltcp_random_u32() -> u32 {
        0
    }

    /// Set the current monotonic time in milliseconds
    ///
    /// Call this from your timer interrupt or monotonic update.
    #[no_mangle]
    pub extern "C" fn smoltcp_set_clock_ms(_ms: u64) {}

    /// Get the current monotonic time in milliseconds
    #[no_mangle]
    pub extern "C" fn smoltcp_clock_now_ms() -> u64 {
        0
    }

    /// Set the network poll callback
    ///
    /// This callback should poll the smoltcp interface and update socket buffers.
    #[no_mangle]
    pub extern "C" fn smoltcp_set_poll_callback(_callback: PollCallback) {}

    /// Poll the network stack
    ///
    /// Calls the registered poll callback if set.
    #[no_mangle]
    pub extern "C" fn smoltcp_poll() -> i32 {
        0
    }

    /// Initialize the platform
    #[no_mangle]
    pub extern "C" fn smoltcp_init() -> i32 {
        0
    }

    /// Cleanup the platform
    #[no_mangle]
    pub extern "C" fn smoltcp_cleanup() {}

    /// Allocate a new socket
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_open() -> i32 {
        0
    }

    /// Initiate a TCP connection
    ///
    /// This stores the connection parameters. The actual connection is established
    /// when the poll callback drives the smoltcp state machine.
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_connect(_handle: i32, _ip: *const u8, _port: u16) -> i32 {
        0
    }

    /// Check if socket is connected
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_is_connected(_handle: i32) -> i32 {
        0
    }

    /// Close a socket
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_close(_handle: i32) -> i32 {
        0
    }

    /// Check if socket can receive data
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_can_recv(_handle: i32) -> i32 {
        0
    }

    /// Check if socket can send data
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_can_send(_handle: i32) -> i32 {
        0
    }

    /// Receive data from socket
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_recv(_handle: i32, _buf: *mut u8, _len: usize) -> i32 {
        0
    }

    /// Send data to socket
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_send(_handle: i32, _buf: *const u8, _len: usize) -> i32 {
        0
    }

    /// Push received data into a socket's RX buffer
    ///
    /// Called by the smoltcp integration layer when data is received.
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_push_rx(_handle: i32, _data: *const u8, _len: usize) -> i32 {
        0
    }

    /// Pop pending data from a socket's TX buffer
    ///
    /// Called by the smoltcp integration layer when ready to send.
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_pop_tx(_handle: i32, _buf: *mut u8, _max_len: usize) -> i32 {
        0
    }

    /// Get socket connection parameters
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_get_remote(
        _handle: i32,
        _ip: *mut u8,
        _port: *mut u16,
    ) -> i32 {
        0
    }

    /// Set socket as connected
    ///
    /// Called by the smoltcp integration layer when connection is established.
    #[no_mangle]
    pub extern "C" fn smoltcp_socket_set_connected(_handle: i32, _connected: bool) {}
}
