/**
 * zenoh-pico-shim Public C API
 *
 * AUTO-GENERATED by cbindgen - DO NOT EDIT MANUALLY
 *
 * This header defines the high-level C API for zenoh-pico that can be
 * called from Rust FFI. It provides session management, publishers, and
 * subscribers with static storage.
 *
 * Platform-specific behavior (threading vs polling) is handled by the
 * backend interface in zenoh_smoltcp_platform.h
 */

#ifndef ZENOH_SHIM_H
#define ZENOH_SHIM_H

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Maximum number of concurrent publishers
 */
#define ZENOH_SHIM_MAX_PUBLISHERS 8

/**
 * Maximum number of concurrent subscribers
 */
#define ZENOH_SHIM_MAX_SUBSCRIBERS 8

/**
 * Success
 */
#define ZENOH_SHIM_OK 0

/**
 * Generic error
 */
#define ZENOH_SHIM_ERR_GENERIC -1

/**
 * Configuration error
 */
#define ZENOH_SHIM_ERR_CONFIG -2

/**
 * Session error
 */
#define ZENOH_SHIM_ERR_SESSION -3

/**
 * Task creation error
 */
#define ZENOH_SHIM_ERR_TASK -4

/**
 * Invalid key expression
 */
#define ZENOH_SHIM_ERR_KEYEXPR -5

/**
 * Resource limit reached
 */
#define ZENOH_SHIM_ERR_FULL -6

/**
 * Invalid handle
 */
#define ZENOH_SHIM_ERR_INVALID -7

/**
 * Publish error
 */
#define ZENOH_SHIM_ERR_PUBLISH -8

/**
 * Callback function type for receiving samples.
 *
 * # Parameters
 * * `data` - Pointer to received data buffer
 * * `len` - Length of data in bytes
 * * `ctx` - User-provided context pointer
 */
typedef void (*ShimCallback)(const uint8_t *data, uintptr_t len, void *ctx);

/**
 * C-compatible callback function pointer type
 */
typedef void (*PollCallback)(void);

/**
 * C-compatible callback function pointer type
 */
typedef void (*PollCallbackFn)(void);

/**
 * Initialize zenoh configuration with client mode and connect locator.
 *
 * # Parameters
 * * `locator` - Connection string (e.g., "tcp/192.168.1.1:7447"), null-terminated.
 *   Can be NULL to use default.
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_init(const char *_locator);

/**
 * Open zenoh session and start background tasks (if threaded backend).
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_open(void);

/**
 * Check if session is currently open.
 *
 * # Returns
 * Non-zero if open, 0 if closed.
 */
int32_t zenoh_shim_is_open(void);

/**
 * Close the session and clean up all resources.
 */
void zenoh_shim_close(void);

/**
 * Declare a publisher for the given key expression.
 *
 * # Parameters
 * * `keyexpr` - Key expression string (e.g., "demo/topic"), null-terminated.
 *
 * # Returns
 * Publisher handle (>= 0) on success, negative error code on failure.
 */
int32_t zenoh_shim_declare_publisher(const char *_keyexpr);

/**
 * Publish data using publisher handle.
 *
 * # Parameters
 * * `handle` - Publisher handle from zenoh_shim_declare_publisher()
 * * `data` - Pointer to data buffer
 * * `len` - Length of data in bytes
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_publish(int32_t _handle, const uint8_t *_data, uintptr_t _len);

/**
 * Undeclare a publisher.
 *
 * # Parameters
 * * `handle` - Publisher handle
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_undeclare_publisher(int32_t _handle);

/**
 * Declare a subscriber for the given key expression.
 *
 * # Parameters
 * * `keyexpr` - Key expression string (e.g., "demo/topic"), null-terminated.
 * * `callback` - Callback function to invoke when samples arrive
 * * `ctx` - User context pointer passed to callback
 *
 * # Returns
 * Subscriber handle (>= 0) on success, negative error code on failure.
 */
int32_t zenoh_shim_declare_subscriber(const char *_keyexpr, ShimCallback _callback, void *_ctx);

/**
 * Undeclare a subscriber.
 *
 * # Parameters
 * * `handle` - Subscriber handle
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_undeclare_subscriber(int32_t _handle);

/**
 * Poll for incoming data and process callbacks.
 *
 * For threaded backends (Zephyr, POSIX), this is a no-op as background
 * tasks handle polling automatically.
 *
 * For polling backends (smoltcp), this must be called regularly to
 * process network data and dispatch callbacks.
 *
 * # Parameters
 * * `timeout_ms` - Maximum time to wait for data (0 = non-blocking)
 *
 * # Returns
 * Number of events processed, or negative on error.
 */
int32_t zenoh_shim_poll(uint32_t _timeout_ms);

/**
 * Combined poll and keepalive operation.
 *
 * This is equivalent to calling zenoh_shim_poll() and performing any
 * necessary keepalive operations. For threaded backends, this is just
 * a brief poll. For polling backends, this handles both network I/O
 * and zenoh protocol maintenance.
 *
 * # Parameters
 * * `timeout_ms` - Maximum time to wait (0 = non-blocking)
 *
 * # Returns
 * Number of events processed, or negative on error.
 */
int32_t zenoh_shim_spin_once(uint32_t _timeout_ms);

/**
 * Check if the current backend uses polling.
 *
 * # Returns
 * true if polling required (smoltcp), false if threaded (Zephyr, POSIX).
 */
bool zenoh_shim_uses_polling(void);

/**
 * Allocate memory
 */
void *smoltcp_alloc(uintptr_t _size);

/**
 * Reallocate memory
 *
 * Note: This is a simplified implementation that allocates new memory
 * and copies the data. The old memory is "leaked" (not reused).
 */
void *smoltcp_realloc(void *_ptr, uintptr_t _size);

/**
 * Free memory (no-op for bump allocator)
 */
void smoltcp_free(void *_ptr);

/**
 * Generate a random u32 using xorshift32
 */
uint32_t smoltcp_random_u32(void);

/**
 * Set the current monotonic time in milliseconds
 *
 * Call this from your timer interrupt or monotonic update.
 */
void smoltcp_set_clock_ms(uint64_t _ms);

/**
 * Get the current monotonic time in milliseconds
 */
uint64_t smoltcp_clock_now_ms(void);

/**
 * Set the network poll callback
 *
 * This callback should poll the smoltcp interface and update socket buffers.
 */
void smoltcp_set_poll_callback(PollCallback _callback);

/**
 * Poll the network stack
 *
 * Calls the registered poll callback if set.
 */
int32_t smoltcp_poll(void);

/**
 * Initialize the platform
 */
int32_t smoltcp_init(void);

/**
 * Cleanup the platform
 */
void smoltcp_cleanup(void);

/**
 * Allocate a new socket
 */
int32_t smoltcp_socket_open(void);

/**
 * Initiate a TCP connection
 *
 * This stores the connection parameters. The actual connection is established
 * when the poll callback drives the smoltcp state machine.
 */
int32_t smoltcp_socket_connect(int32_t _handle, const uint8_t *_ip, uint16_t _port);

/**
 * Check if socket is connected
 */
int32_t smoltcp_socket_is_connected(int32_t _handle);

/**
 * Close a socket
 */
int32_t smoltcp_socket_close(int32_t _handle);

/**
 * Check if socket can receive data
 */
int32_t smoltcp_socket_can_recv(int32_t _handle);

/**
 * Check if socket can send data
 */
int32_t smoltcp_socket_can_send(int32_t _handle);

/**
 * Receive data from socket
 */
int32_t smoltcp_socket_recv(int32_t _handle, uint8_t *_buf, uintptr_t _len);

/**
 * Send data to socket
 */
int32_t smoltcp_socket_send(int32_t _handle, const uint8_t *_buf, uintptr_t _len);

/**
 * Push received data into a socket's RX buffer
 *
 * Called by the smoltcp integration layer when data is received.
 */
int32_t smoltcp_socket_push_rx(int32_t _handle, const uint8_t *_data, uintptr_t _len);

/**
 * Pop pending data from a socket's TX buffer
 *
 * Called by the smoltcp integration layer when ready to send.
 */
int32_t smoltcp_socket_pop_tx(int32_t _handle, uint8_t *_buf, uintptr_t _max_len);

/**
 * Get socket connection parameters
 */
int32_t smoltcp_socket_get_remote(int32_t _handle, uint8_t *_ip, uint16_t *_port);

/**
 * Set socket as connected
 *
 * Called by the smoltcp integration layer when connection is established.
 */
void smoltcp_socket_set_connected(int32_t _handle, bool _connected);

/**
 * Allocate memory
 */
void *smoltcp_alloc(uintptr_t size);

/**
 * Reallocate memory
 *
 * Note: This is a simplified implementation that allocates new memory
 * and copies the data. The old memory is "leaked" (not reused).
 */
void *smoltcp_realloc(void *ptr, uintptr_t size);

/**
 * Free memory (no-op for bump allocator)
 */
void smoltcp_free(void *_ptr);

/**
 * Generate a random u32 using xorshift32
 */
uint32_t smoltcp_random_u32(void);

/**
 * Set the current monotonic time in milliseconds
 *
 * Call this from your timer interrupt or monotonic update.
 */
void smoltcp_set_clock_ms(uint64_t ms);

/**
 * Get the current monotonic time in milliseconds
 */
uint64_t smoltcp_clock_now_ms(void);

/**
 * Set the network poll callback
 *
 * This callback should poll the smoltcp interface and update socket buffers.
 */
void smoltcp_set_poll_callback(PollCallbackFn callback);

/**
 * Poll the network stack
 *
 * Calls the registered poll callback if set.
 */
int32_t smoltcp_poll(void);

/**
 * Initialize the platform
 */
int32_t smoltcp_init(void);

/**
 * Cleanup the platform
 */
void smoltcp_cleanup(void);

/**
 * Allocate a new socket
 */
int32_t smoltcp_socket_open(void);

/**
 * Initiate a TCP connection
 *
 * This stores the connection parameters. The actual connection is established
 * when the poll callback drives the smoltcp state machine.
 */
int32_t smoltcp_socket_connect(int32_t handle, const uint8_t *ip, uint16_t port);

/**
 * Check if socket is connected
 */
int32_t smoltcp_socket_is_connected(int32_t handle);

/**
 * Close a socket
 */
int32_t smoltcp_socket_close(int32_t handle);

/**
 * Check if socket can receive data
 */
int32_t smoltcp_socket_can_recv(int32_t handle);

/**
 * Check if socket can send data
 */
int32_t smoltcp_socket_can_send(int32_t handle);

/**
 * Receive data from socket
 */
int32_t smoltcp_socket_recv(int32_t handle, uint8_t *buf, uintptr_t len);

/**
 * Send data to socket
 */
int32_t smoltcp_socket_send(int32_t handle, const uint8_t *buf, uintptr_t len);

/**
 * Push received data into a socket's RX buffer
 *
 * Called by the smoltcp integration layer when data is received.
 */
int32_t smoltcp_socket_push_rx(int32_t handle, const uint8_t *data, uintptr_t len);

/**
 * Pop pending data from a socket's TX buffer
 *
 * Called by the smoltcp integration layer when ready to send.
 */
int32_t smoltcp_socket_pop_tx(int32_t handle, uint8_t *buf, uintptr_t max_len);

/**
 * Get socket connection parameters
 */
int32_t smoltcp_socket_get_remote(int32_t handle, uint8_t *ip, uint16_t *port);

/**
 * Set socket as connected
 *
 * Called by the smoltcp integration layer when connection is established.
 */
void smoltcp_socket_set_connected(int32_t handle, bool connected);

#endif  /* ZENOH_SHIM_H */
