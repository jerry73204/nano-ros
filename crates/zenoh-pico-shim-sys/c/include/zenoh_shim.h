/**
 * zenoh-pico-shim Public C API
 *
 * AUTO-GENERATED by cbindgen - DO NOT EDIT MANUALLY
 *
 * This header defines the high-level C API for zenoh-pico that can be
 * called from Rust FFI. It provides session management, publishers, and
 * subscribers with static storage.
 *
 * Platform-specific behavior (threading vs polling) is handled by the
 * backend interface in zenoh_smoltcp_platform.h
 */

#ifndef ZENOH_SHIM_H
#define ZENOH_SHIM_H

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Maximum number of concurrent publishers
 */
#define ZENOH_SHIM_MAX_PUBLISHERS 8

/**
 * Maximum number of concurrent subscribers
 */
#define ZENOH_SHIM_MAX_SUBSCRIBERS 8

/**
 * Maximum number of concurrent liveliness tokens
 */
#define ZENOH_SHIM_MAX_LIVELINESS 16

/**
 * Maximum number of concurrent queryables
 */
#define ZENOH_SHIM_MAX_QUERYABLES 8

/**
 * Size of Zenoh ID in bytes
 */
#define ZENOH_SHIM_ZID_SIZE 16

/**
 * Size of RMW GID in bytes (for ROS 2 humble compatibility)
 */
#define ZENOH_SHIM_RMW_GID_SIZE 16

/**
 * Success
 */
#define ZENOH_SHIM_OK 0

/**
 * Generic error
 */
#define ZENOH_SHIM_ERR_GENERIC -1

/**
 * Configuration error
 */
#define ZENOH_SHIM_ERR_CONFIG -2

/**
 * Session error
 */
#define ZENOH_SHIM_ERR_SESSION -3

/**
 * Task creation error
 */
#define ZENOH_SHIM_ERR_TASK -4

/**
 * Invalid key expression
 */
#define ZENOH_SHIM_ERR_KEYEXPR -5

/**
 * Resource limit reached
 */
#define ZENOH_SHIM_ERR_FULL -6

/**
 * Invalid handle
 */
#define ZENOH_SHIM_ERR_INVALID -7

/**
 * Publish error
 */
#define ZENOH_SHIM_ERR_PUBLISH -8

/**
 * Query timeout
 */
#define ZENOH_SHIM_ERR_TIMEOUT -9

/**
 * Callback function type for receiving samples.
 *
 * # Parameters
 * * `data` - Pointer to received data buffer
 * * `len` - Length of data in bytes
 * * `ctx` - User-provided context pointer
 */
typedef void (*ShimCallback)(const uint8_t *data, uintptr_t len, void *ctx);

/**
 * Callback function type for receiving queries (service requests).
 *
 * # Parameters
 * * `keyexpr` - Key expression string (not null-terminated)
 * * `keyexpr_len` - Length of key expression
 * * `payload` - Pointer to request payload (may be NULL)
 * * `payload_len` - Length of payload in bytes
 * * `ctx` - User-provided context pointer
 */
typedef void (*ShimQueryCallback)(const char *keyexpr,
                                  uintptr_t keyexpr_len,
                                  const uint8_t *payload,
                                  uintptr_t payload_len,
                                  void *ctx);

/**
 * C-compatible callback function pointer type
 */
typedef void (*PollCallback)(void);

/**
 * C-compatible callback function pointer type
 */
typedef void (*PollCallbackFn)(void);

/**
 * Initialize zenoh configuration with client mode and connect locator.
 *
 * # Parameters
 * * `locator` - Connection string (e.g., "tcp/192.168.1.1:7447"), null-terminated.
 *   Can be NULL to use default.
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_init(const char *_locator);

/**
 * Open zenoh session and start background tasks (if threaded backend).
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_open(void);

/**
 * Check if session is currently open.
 *
 * # Returns
 * Non-zero if open, 0 if closed.
 */
int32_t zenoh_shim_is_open(void);

/**
 * Close the session and clean up all resources.
 */
void zenoh_shim_close(void);

/**
 * Declare a publisher for the given key expression.
 *
 * # Parameters
 * * `keyexpr` - Key expression string (e.g., "demo/topic"), null-terminated.
 *
 * # Returns
 * Publisher handle (>= 0) on success, negative error code on failure.
 */
int32_t zenoh_shim_declare_publisher(const char *_keyexpr);

/**
 * Publish data using publisher handle.
 *
 * # Parameters
 * * `handle` - Publisher handle from zenoh_shim_declare_publisher()
 * * `data` - Pointer to data buffer
 * * `len` - Length of data in bytes
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_publish(int32_t _handle, const uint8_t *_data, uintptr_t _len);

/**
 * Undeclare a publisher.
 *
 * # Parameters
 * * `handle` - Publisher handle
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_undeclare_publisher(int32_t _handle);

/**
 * Declare a subscriber for the given key expression.
 *
 * # Parameters
 * * `keyexpr` - Key expression string (e.g., "demo/topic"), null-terminated.
 * * `callback` - Callback function to invoke when samples arrive
 * * `ctx` - User context pointer passed to callback
 *
 * # Returns
 * Subscriber handle (>= 0) on success, negative error code on failure.
 */
int32_t zenoh_shim_declare_subscriber(const char *_keyexpr, ShimCallback _callback, void *_ctx);

/**
 * Undeclare a subscriber.
 *
 * # Parameters
 * * `handle` - Subscriber handle
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_undeclare_subscriber(int32_t _handle);

/**
 * Poll for incoming data and process callbacks.
 *
 * For threaded backends (Zephyr, POSIX), this is a no-op as background
 * tasks handle polling automatically.
 *
 * For polling backends (smoltcp), this must be called regularly to
 * process network data and dispatch callbacks.
 *
 * # Parameters
 * * `timeout_ms` - Maximum time to wait for data (0 = non-blocking)
 *
 * # Returns
 * Number of events processed, or negative on error.
 */
int32_t zenoh_shim_poll(uint32_t _timeout_ms);

/**
 * Combined poll and keepalive operation.
 *
 * This is equivalent to calling zenoh_shim_poll() and performing any
 * necessary keepalive operations. For threaded backends, this is just
 * a brief poll. For polling backends, this handles both network I/O
 * and zenoh protocol maintenance.
 *
 * # Parameters
 * * `timeout_ms` - Maximum time to wait (0 = non-blocking)
 *
 * # Returns
 * Number of events processed, or negative on error.
 */
int32_t zenoh_shim_spin_once(uint32_t _timeout_ms);

/**
 * Check if the current backend uses polling.
 *
 * # Returns
 * true if polling required (smoltcp), false if threaded (Zephyr, POSIX).
 */
bool zenoh_shim_uses_polling(void);

/**
 * Get the session's Zenoh ID.
 *
 * # Parameters
 * * `zid_out` - Pointer to 16-byte buffer to receive the ZID
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_get_zid(uint8_t *_zid_out);

/**
 * Declare a liveliness token for ROS 2 discovery.
 *
 * # Parameters
 * * `keyexpr` - Key expression string, null-terminated.
 *
 * # Returns
 * Liveliness handle (>= 0) on success, negative error code on failure.
 */
int32_t zenoh_shim_declare_liveliness(const char *_keyexpr);

/**
 * Undeclare a liveliness token.
 *
 * # Parameters
 * * `handle` - Liveliness handle
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_undeclare_liveliness(int32_t _handle);

/**
 * Publish data with an attachment (for RMW compatibility).
 *
 * # Parameters
 * * `handle` - Publisher handle
 * * `data` - Pointer to data buffer
 * * `len` - Length of data in bytes
 * * `attachment` - Pointer to attachment buffer (may be NULL)
 * * `attachment_len` - Length of attachment in bytes
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_publish_with_attachment(int32_t _handle,
                                           const uint8_t *_data,
                                           uintptr_t _len,
                                           const uint8_t *_attachment,
                                           uintptr_t _attachment_len);

/**
 * Declare a queryable for receiving service requests.
 *
 * # Parameters
 * * `keyexpr` - Key expression string, null-terminated.
 * * `callback` - Callback function to invoke when queries arrive
 * * `ctx` - User context pointer passed to callback
 *
 * # Returns
 * Queryable handle (>= 0) on success, negative error code on failure.
 */
int32_t zenoh_shim_declare_queryable(const char *_keyexpr, ShimQueryCallback _callback, void *_ctx);

/**
 * Undeclare a queryable.
 *
 * # Parameters
 * * `handle` - Queryable handle
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_undeclare_queryable(int32_t _handle);

/**
 * Reply to a query (must be called within query callback).
 *
 * # Parameters
 * * `keyexpr` - Reply key expression string, null-terminated.
 * * `data` - Pointer to reply data buffer
 * * `len` - Length of data in bytes
 * * `attachment` - Pointer to attachment buffer (may be NULL)
 * * `attachment_len` - Length of attachment in bytes
 *
 * # Returns
 * 0 on success, negative error code on failure.
 */
int32_t zenoh_shim_query_reply(const char *_keyexpr,
                               const uint8_t *_data,
                               uintptr_t _len,
                               const uint8_t *_attachment,
                               uintptr_t _attachment_len);

/**
 * Send a query and wait for reply (blocking, for service client).
 *
 * # Parameters
 * * `keyexpr` - Key expression string, null-terminated.
 * * `payload` - Request payload (may be NULL)
 * * `payload_len` - Length of payload in bytes
 * * `reply_buf` - Buffer to receive reply data
 * * `reply_buf_size` - Size of reply buffer
 * * `timeout_ms` - Timeout in milliseconds
 *
 * # Returns
 * Number of bytes in reply on success, negative error code on failure.
 */
int32_t zenoh_shim_get(const char *_keyexpr,
                       const uint8_t *_payload,
                       uintptr_t _payload_len,
                       uint8_t *_reply_buf,
                       uintptr_t _reply_buf_size,
                       uint32_t _timeout_ms);

/**
 * Allocate memory
 */
void *smoltcp_alloc(uintptr_t _size);

/**
 * Reallocate memory
 *
 * Note: This is a simplified implementation that allocates new memory
 * and copies the data. The old memory is "leaked" (not reused).
 */
void *smoltcp_realloc(void *_ptr, uintptr_t _size);

/**
 * Free memory (no-op for bump allocator)
 */
void smoltcp_free(void *_ptr);

/**
 * Generate a random u32 using xorshift32
 */
uint32_t smoltcp_random_u32(void);

/**
 * Set the current monotonic time in milliseconds
 *
 * Call this from your timer interrupt or monotonic update.
 */
void smoltcp_set_clock_ms(uint64_t _ms);

/**
 * Get the current monotonic time in milliseconds
 */
uint64_t smoltcp_clock_now_ms(void);

/**
 * Set the network poll callback
 *
 * This callback should poll the smoltcp interface and update socket buffers.
 */
void smoltcp_set_poll_callback(PollCallback _callback);

/**
 * Poll the network stack
 *
 * Calls the registered poll callback if set.
 */
int32_t smoltcp_poll(void);

/**
 * Initialize the platform
 */
int32_t smoltcp_init(void);

/**
 * Cleanup the platform
 */
void smoltcp_cleanup(void);

/**
 * Allocate a new socket
 */
int32_t smoltcp_socket_open(void);

/**
 * Initiate a TCP connection
 *
 * This stores the connection parameters. The actual connection is established
 * when the poll callback drives the smoltcp state machine.
 */
int32_t smoltcp_socket_connect(int32_t _handle, const uint8_t *_ip, uint16_t _port);

/**
 * Check if socket is connected
 */
int32_t smoltcp_socket_is_connected(int32_t _handle);

/**
 * Close a socket
 */
int32_t smoltcp_socket_close(int32_t _handle);

/**
 * Check if socket can receive data
 */
int32_t smoltcp_socket_can_recv(int32_t _handle);

/**
 * Check if socket can send data
 */
int32_t smoltcp_socket_can_send(int32_t _handle);

/**
 * Receive data from socket
 */
int32_t smoltcp_socket_recv(int32_t _handle, uint8_t *_buf, uintptr_t _len);

/**
 * Send data to socket
 */
int32_t smoltcp_socket_send(int32_t _handle, const uint8_t *_buf, uintptr_t _len);

/**
 * Push received data into a socket's RX buffer
 *
 * Called by the smoltcp integration layer when data is received.
 */
int32_t smoltcp_socket_push_rx(int32_t _handle, const uint8_t *_data, uintptr_t _len);

/**
 * Pop pending data from a socket's TX buffer
 *
 * Called by the smoltcp integration layer when ready to send.
 */
int32_t smoltcp_socket_pop_tx(int32_t _handle, uint8_t *_buf, uintptr_t _max_len);

/**
 * Get socket connection parameters
 */
int32_t smoltcp_socket_get_remote(int32_t _handle, uint8_t *_ip, uint16_t *_port);

/**
 * Set socket as connected
 *
 * Called by the smoltcp integration layer when connection is established.
 */
void smoltcp_socket_set_connected(int32_t _handle, bool _connected);

#endif  /* ZENOH_SHIM_H */
