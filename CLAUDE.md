# nano-ros

A lightweight ROS 2 client for embedded real-time systems (Zephyr, NuttX). Rewrite of Pico-ROS with `no_std` support.

## Project Overview

Pico-ROS is a lightweight ROS client for resource-constrained embedded systems. This project rewrites it in Rust with:
- `no_std` support for bare-metal and RTOS targets
- Zero-copy serialization where possible
- Compile-time type safety via traits and proc macros
- Async-ready design for non-blocking I/O

## Original Pico-ROS Architecture

### Core Components

| Component | File | Purpose |
|-----------|------|---------|
| picoros | `picoros.h/c` | Core ROS client (nodes, pub/sub, services) |
| picoserdes | `picoserdes.h/c` | CDR serialization via X-macros |
| picoparams | `picoparams.h/c` | ROS 2 parameter server |

### Dependencies
- **zenoh-pico**: Lightweight pub/sub middleware
- **Micro-CDR**: eProsima's CDR serialization library

## Workspace Structure

```
nano-ros/
├── Cargo.toml                 # Workspace root
├── CLAUDE.md
├── crates/
│   ├── nano-ros-core/         # Core types, traits, node abstraction
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── node.rs        # Node, Publisher, Subscriber
│   │       ├── service.rs     # Service server/client
│   │       ├── error.rs       # Error types
│   │       └── types.rs       # Core ROS type traits
│   │
│   ├── nano-ros-serdes/       # CDR serialization/deserialization
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── cdr.rs         # CDR encoder/decoder
│   │       ├── traits.rs      # Serialize/Deserialize traits
│   │       └── primitives.rs  # Base type implementations
│   │
│   ├── nano-ros-macros/       # Proc macros for message types
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── lib.rs         # #[derive(RosMessage)], etc.
│   │
│   ├── nano-ros-types/        # Standard ROS message types
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── std_msgs.rs    # std_msgs::msg::*
│   │       ├── geometry_msgs.rs
│   │       └── sensor_msgs.rs
│   │
│   ├── nano-ros-params/       # Parameter server (optional)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── server.rs
│   │       └── types.rs
│   │
│   ├── nano-ros-transport/    # Transport abstraction (zenoh backend)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── traits.rs      # Transport trait
│   │       └── zenoh.rs       # Zenoh implementation
│   │
│   ├── zenoh-pico-sys/        # Unsafe FFI bindings to zenoh-pico C library
│   │   ├── Cargo.toml
│   │   ├── build.rs           # CMake build + bindgen
│   │   └── src/
│   │       └── lib.rs         # Generated bindings re-export
│   │
│   └── zenoh-pico/            # Safe Rust wrapper for zenoh-pico
│       ├── Cargo.toml
│       ├── src/
│       │   ├── lib.rs
│       │   ├── config.rs      # Config, Mode (Client/Peer)
│       │   ├── error.rs       # Error, Result types
│       │   ├── keyexpr.rs     # KeyExpr (topic paths)
│       │   ├── publisher.rs   # Publisher
│       │   ├── session.rs     # Session (connection management)
│       │   └── subscriber.rs  # Subscriber, Sample
│       └── tests/
│           └── integration.rs # Integration tests
│
└── examples/
    ├── talker.rs
    ├── listener.rs
    └── service.rs
```

## Zenoh-Pico Bindings

Two crates provide Rust bindings for zenoh-pico:

### zenoh-pico-sys (FFI Layer)
Low-level unsafe bindings generated by bindgen:
- Compiles zenoh-pico C library via CMake
- Generates Rust FFI bindings automatically
- Links statically (`links = "zenohpico"`)
- No `std` required

### zenoh-pico (Safe Wrapper)
Idiomatic Rust API wrapping zenoh-pico-sys:

```rust
use zenoh_pico::{Config, Session, KeyExpr};

// Open a session
let config = Config::client("tcp/127.0.0.1:7447")?;
let session = Session::open(config)?;

// Publish
let keyexpr = KeyExpr::new("demo/topic")?;
let publisher = session.declare_publisher(&keyexpr)?;
publisher.put(b"Hello")?;

// Subscribe
let subscriber = session.declare_subscriber(&keyexpr, |sample| {
    println!("Received: {:?}", sample.payload);
})?;
```

**Key Types:**
- `Config` - Session configuration (client/peer mode, locators)
- `Session` - Connection to zenoh network (manages read/lease tasks)
- `KeyExpr` - Topic path with wildcard support
- `Publisher` - Sends data to a key expression
- `Subscriber<F>` - Receives data via callback
- `Sample` - Received message with payload

**Design Notes:**
- `#![no_std]` compatible (requires `alloc` for `Subscriber`)
- Session/Publisher/Subscriber are `Send` but not `Sync`
- Background read/lease tasks started automatically on session open
- RAII: resources cleaned up on drop

**Requirements:**
- Some tests require a running `zenohd` router on `tcp/127.0.0.1:7447`
- Same-session pub/sub requires `Z_FEATURE_LOCAL_SUBSCRIBER=1` (enabled in build)

**Fixed Issues:**
- **KeyExpr dangling pointer bug** - `z_view_keyexpr_t` stores a pointer to the string buffer. When the `KeyExpr` struct was moved (e.g., returned from function), the buffer moved but the pointer didn't update, causing zenoh-pico to read garbage. Fixed by using owned keyexpr (`z_owned_keyexpr_t`) which copies the data.
- Double-free SIGSEGV in subscriber error handling path
- Double-free SIGSEGV when storing context in both Rust struct and closure

## Key Design Decisions

### 1. `no_std` Support

All core crates must support `#![no_std]` with optional `std` feature:

```rust
#![no_std]

#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "alloc")]
extern crate alloc;
```

**Feature flags:**
- `std` - Full standard library (desktop/Linux)
- `alloc` - Dynamic allocation only (embedded with heap)
- (default) - No heap, static buffers only

### 2. Type System (Replacing X-Macros)

Use Rust traits + proc macros instead of C X-macros:

```rust
// In nano-ros-core/src/types.rs
pub trait RosMessage: Sized {
    const TYPE_NAME: &'static str;
    const RIHS_HASH: &'static str;

    fn serialize<W: CdrWriter>(&self, writer: &mut W) -> Result<(), SerError>;
    fn deserialize<R: CdrReader>(reader: &mut R) -> Result<Self, DeserError>;
}

// Generated via proc macro
#[derive(RosMessage)]
#[ros(type_name = "std_msgs::msg::dds_::String_")]
pub struct StringMsg {
    pub data: heapless::String<256>,  // no_std compatible
}
```

### 3. Memory Management

**Static buffers for `no_std`:**
```rust
use heapless::{String, Vec};

pub struct Publisher<const BUF_SIZE: usize> {
    buffer: [u8; BUF_SIZE],
    // ...
}
```

**Dynamic allocation with `alloc` feature:**
```rust
#[cfg(feature = "alloc")]
use alloc::{string::String, vec::Vec};
```

### 4. Async Support

Design for async but don't require it:

```rust
// Blocking API (always available)
pub fn publish<M: RosMessage>(&mut self, msg: &M) -> Result<(), Error>;

// Async API (with feature flag)
#[cfg(feature = "async")]
pub async fn publish_async<M: RosMessage>(&mut self, msg: &M) -> Result<(), Error>;
```

### 5. Transport Abstraction

Abstract over zenoh-pico for portability:

```rust
pub trait Transport {
    type Publisher: TransportPublisher;
    type Subscriber: TransportSubscriber;
    type Error;

    fn create_publisher(&mut self, topic: &TopicInfo) -> Result<Self::Publisher, Self::Error>;
    fn create_subscriber<F>(&mut self, topic: &TopicInfo, callback: F) -> Result<Self::Subscriber, Self::Error>
    where F: FnMut(&[u8]) + Send;
}
```

## Original Pico-ROS Key Structures

### Node
```c
typedef struct {
    char* name;
    uint32_t domain_id;
    char guid[17];
    z_owned_session_t* session;
    zc_owned_liveliness_token_t node_token;
} picoros_node_t;
```

### Publisher
```c
typedef struct {
    z_owned_publisher_t publisher;
    char* topic_name;
    char* topic_type;
    char* rihs_hash;
    rmw_attachment_t attachment;
    z_publisher_put_options_t options;
    zc_owned_liveliness_token_t pub_token;
} picoros_publisher_t;
```

### Subscriber
```c
typedef struct {
    z_owned_subscriber_t subscriber;
    char* topic_name;
    char* topic_type;
    char* rihs_hash;
    picoros_sub_cb_t callback;
    void* userdata;
    zc_owned_liveliness_token_t sub_token;
} picoros_subscriber_t;
```

### RMW Attachment (for rmw_zenoh compatibility)
```c
typedef struct __attribute__((__packed__)) {
    int64_t sequence_number;
    int64_t time;
    uint8_t rmw_gid_size;
    uint8_t rmw_gid[16];
} rmw_attachment_t;
```

## CDR Serialization Format

- 4-byte header: `0x00 0x01 0x00 0x00` (little-endian CDR)
- Alignment: primitives aligned to their size
- Strings: 4-byte length prefix + data + null terminator
- Sequences: 4-byte count + elements

## Topic Naming Convention (rmw_zenoh compatible)

**Data key expression format (for ROS 2 Humble):**
```
<domain_id>/<topic_name>/<message_type>/<type_hash>
```

Example:
```
0/chatter/std_msgs::msg::dds_::Int32_/TypeHashNotSupported
```

**Note:** For Humble, use `TypeHashNotSupported` as the type hash (no `RIHS01_` prefix).
Newer ROS 2 versions (Iron+) use `RIHS01_<sha256>` format.

## Service Naming Convention

```
<domain_id>/<service_name>/<service_type>_/RIHS01_<hash>
```

## Liveliness Token Format

**Node:**
```
@ros2_lv/<domain_id>/<zid>/0/0/NN/%/%/<node_name>
```

**Publisher:**
```
@ros2_lv/<domain_id>/<zid>/0/11/MP/%/%/<node_name>/%<topic>/<type>/RIHS01_<hash>/<qos>
```

**Subscriber:**
```
@ros2_lv/<domain_id>/<zid>/0/11/MS/%/%/<node_name>/%<topic>/<type>/RIHS01_<hash>/<qos>
```

Key points:
- ZenohId must be LSB-first hex format
- Topic names use `%` prefix (e.g., `%chatter`)
- Liveliness tokens **do** use `RIHS01_` prefix (unlike data keyexprs)
- QoS format: `reliability:durability:history,depth:...` (e.g., `2:2:1,1:,:,:,,` for BEST_EFFORT)

## Build Commands

Use `just` for common tasks (default recipes use `no_std`):

```bash
just setup          # Install toolchains and tools
just build          # Build with no_std (default)
just build-embedded # Build for thumbv7em-none-eabihf
just check          # Format + clippy with no_std
just test           # Run tests (requires std)
just test-miri      # Run Miri for undefined behavior detection
just test-all       # Run test + test-miri
just format         # Format code (nightly)
just quality        # Run check + test
just doc            # Generate and open docs
just clean          # Clean build artifacts

# zenoh-pico specific
cargo test -p zenoh-pico  # Run zenoh-pico tests (no router needed for most)
```

**Toolchain**: `rust-toolchain.toml` configures stable + `thumbv7em-none-eabihf` target.

## Target Platform Notes

### Zephyr RTOS
- Use `zenoh-pico` Zephyr port
- Configure via Kconfig/devicetree
- Consider `embassy` for async

### NuttX RTOS
- POSIX-like interface simplifies porting
- Can use `std` with NuttX's libc
- `zenoh-pico` has NuttX support

## Error Handling

Use `Result<T, E>` throughout:

```rust
#[derive(Debug)]
pub enum Error {
    Serialization(SerError),
    Transport(TransportError),
    Timeout,
    InvalidMessage,
    BufferTooSmall,
}
```

## Testing Strategy

- Unit tests with `#[cfg(test)]` (requires `std`)
- Miri tests for undefined behavior detection
- CDR format compatibility tests against Micro-CDR
- QEMU tests for Cortex-M targets (Phase 2)
- Integration tests against real zenoh router
- Multi-node QEMU testing (Zephyr + native)
- Consider `defmt` for embedded debugging

## Development Practices

### System Package Installation

**Never install system packages directly.** When a system package is needed:
1. Stop and inform the user what package is required
2. Provide the exact installation command for them to run
3. Continue after user confirms installation

Example:
```
QEMU ARM emulator is required but not installed.
Please run: sudo apt install qemu-system-arm
```

This ensures the user maintains control over their system and is aware of all dependencies being installed.

### Quality Checks

**Always run `just quality` after completing a task.** This runs:
1. Format check (`cargo +nightly fmt --check`)
2. Clippy with no default features (`-D warnings`)
3. All tests via nextest

Fix any issues before considering a task complete.

## Documentation

Development documentation lives in `docs/`:

```
docs/
├── rmw_zenoh_interop.md           # ROS 2 rmw_zenoh protocol documentation
├── roadmap/                       # Development phases and milestones
│   ├── phase-1-foundation.md      # CDR, types, macros (COMPLETE)
│   └── phase-2-zephyr-qemu.md     # Zephyr, QEMU, transport (PLANNING)
├── architecture/                  # Design documents and ADRs
└── api/                           # API documentation (if not rustdoc)
```

## Development Phases

| Phase | Focus | Status |
|-------|-------|--------|
| Phase 1 | CDR serialization, types, proc macros | **Complete** |
| Phase 2A | ROS 2 Interoperability | **Complete** |
| Phase 2B | Zephyr integration, QEMU testing | Pending |
| Phase 3 | Services, parameters, safety certification | Future |

### Phase 2A Progress (ROS 2 Interoperability) - COMPLETE
- [x] `zenoh-pico-sys` - FFI bindings with static linking
- [x] `zenoh-pico` - Safe wrapper (Config, Session, Publisher, Subscriber, Liveliness)
- [x] `nano-ros-transport` - ZenohTransport backend with RMW Attachment support
- [x] `nano-ros-node` - ConnectedNode with transport integration
- [x] RMW Attachment support - Required metadata for rmw_zenoh compatibility
- [x] Liveliness tokens - Node/publisher/subscriber discovery
- [x] Native examples updated - talker/listener use real zenoh transport
- [x] nano-ros ↔ nano-ros communication tested and working
- [x] ROS 2 → nano-ros communication working (via wildcard subscriber)
- [x] nano-ros → ROS 2 communication working (Humble)

### Phase 2B Progress (Zephyr/QEMU)
- [ ] Zephyr QEMU testing environment
- [ ] Multi-node testing (Zephyr + native)

## ROS 2 rmw_zenoh Interoperability

See `docs/rmw_zenoh_interop.md` for detailed protocol documentation.

### Current Status - WORKING

| Direction | Status | Notes |
|-----------|--------|-------|
| nano-ros ↔ nano-ros | ✅ Working | Full pub/sub communication |
| ROS 2 → nano-ros | ✅ Working | Uses wildcard subscriber to match any type hash |
| nano-ros → ROS 2 | ✅ Working | Tested with ROS 2 Humble + rmw_zenoh_cpp |

### Key Implementation Details

1. **Data keyexpr format**: For Humble, use `TypeHashNotSupported` without `RIHS01_` prefix
2. **Liveliness tokens**: Use `RIHS01_` prefix, `%` for topic names, LSB-first ZenohId
3. **QoS string**: Use explicit values `2:2:1,1:,:,:,,` (BEST_EFFORT/VOLATILE)
4. **RMW Attachment**: 33 bytes (8+8+1+16) using zenoh serializer for compatibility

### Test Commands

```bash
# Terminal 1: Start zenoh router
zenohd --listen tcp/127.0.0.1:7447

# Terminal 2: Run nano-ros talker
cargo run -p native-talker --features zenoh -- --tcp 127.0.0.1:7447

# Terminal 3: Run ROS 2 listener
source /opt/ros/humble/setup.bash
export RMW_IMPLEMENTATION=rmw_zenoh_cpp
export ZENOH_CONFIG_OVERRIDE='mode="client";connect/endpoints=["tcp/127.0.0.1:7447"]'
ros2 topic echo /chatter std_msgs/msg/Int32 --qos-reliability best_effort
```

Test scripts available:
- `scripts/test-qos.sh` - Test nano-ros → ROS 2 communication
- `scripts/test-pubsub.sh` - Test nano-ros ↔ nano-ros (requires zenohd)
- `scripts/test-pubsub-peer.sh` - Test peer mode (no router)

## References

- Original Pico-ROS: `external/Pico-ROS-software/`
- zenoh-pico: `external/Pico-ROS-software/thirdparty/zenoh-pico/`
- Micro-CDR: `external/Pico-ROS-software/thirdparty/Micro-CDR/`
- ROS 2 CDR spec: OMG DDS-XTypes
- rmw_zenoh: https://github.com/ros2/rmw_zenoh
- Zephyr Rust: https://github.com/zephyrproject-rtos/zephyr-lang-rust
- Embassy: https://embassy.dev/
- Ferrocene (deferred): https://ferrocene.dev/
