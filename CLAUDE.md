# nano-ros

A lightweight ROS 2 client for embedded real-time systems (Zephyr, NuttX). Rewrite of Pico-ROS with `no_std` support.

## Project Overview

Pico-ROS is a lightweight ROS client for resource-constrained embedded systems. This project rewrites it in Rust with:
- `no_std` support for bare-metal and RTOS targets
- Zero-copy serialization where possible
- Compile-time type safety via traits and proc macros
- Async-ready design for non-blocking I/O

## Original Pico-ROS Architecture

### Core Components

| Component | File | Purpose |
|-----------|------|---------|
| picoros | `picoros.h/c` | Core ROS client (nodes, pub/sub, services) |
| picoserdes | `picoserdes.h/c` | CDR serialization via X-macros |
| picoparams | `picoparams.h/c` | ROS 2 parameter server |

### Dependencies
- **zenoh-pico**: Lightweight pub/sub middleware
- **Micro-CDR**: eProsima's CDR serialization library

## Workspace Structure

```
nano-ros/
├── Cargo.toml                 # Workspace root
├── CLAUDE.md
├── crates/
│   ├── nano-ros/              # Unified API crate (like rclcpp/rclpy)
│   │   ├── Cargo.toml         # Re-exports all sub-crates
│   │   └── src/
│   │       └── lib.rs         # Main entry point with prelude
│   │
│   ├── nano-ros-core/         # Core types, traits, node abstraction
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── node.rs        # Node, Publisher, Subscriber
│   │       ├── service.rs     # Service traits (RosService, Request/Response)
│   │       ├── error.rs       # Error types
│   │       └── types.rs       # Core ROS type traits
│   │
│   ├── nano-ros-serdes/       # CDR serialization/deserialization
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── cdr.rs         # CDR encoder/decoder
│   │       ├── traits.rs      # Serialize/Deserialize traits
│   │       └── primitives.rs  # Base type implementations
│   │
│   ├── nano-ros-macros/       # Proc macros for message types
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── lib.rs         # #[derive(RosMessage)], etc.
│   │
│   ├── nano-ros-params/       # Parameter server (ROS 2 compatible)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── server.rs      # ParameterServer with static storage
│   │       └── types.rs       # ParameterValue, ParameterDescriptor, etc.
│   │
│   ├── nano-ros-transport/    # Transport abstraction (zenoh backend)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── traits.rs      # Transport trait
│   │       └── zenoh.rs       # Zenoh implementation
│   │
│   ├── zenoh-pico-sys/        # Unsafe FFI bindings to zenoh-pico C library
│   │   ├── Cargo.toml
│   │   ├── build.rs           # CMake build + bindgen
│   │   └── src/
│   │       └── lib.rs         # Generated bindings re-export
│   │
│   └── zenoh-pico/            # Safe Rust wrapper for zenoh-pico
│       ├── Cargo.toml
│       ├── src/
│       │   ├── lib.rs
│       │   ├── config.rs      # Config, Mode (Client/Peer)
│       │   ├── error.rs       # Error, Result types
│       │   ├── keyexpr.rs     # KeyExpr (topic paths)
│       │   ├── publisher.rs   # Publisher
│       │   ├── session.rs     # Session (connection management)
│       │   └── subscriber.rs  # Subscriber, Sample
│       └── tests/
│           └── integration.rs # Integration tests
│
├── colcon-nano-ros/           # Message binding generator
│   └── packages/
│       ├── cargo-nano-ros/    # cargo nano-ros subcommand
│       ├── rosidl-bindgen/    # Binding generator library
│       ├── rosidl-codegen/    # Code generator with templates
│       └── rosidl-parser/     # ROS IDL parser
│
└── examples/                  # Standalone packages (excluded from workspace)
    ├── native-talker/         # Pub/sub example with std_msgs
    │   ├── package.xml        # Declares std_msgs dependency
    │   ├── Cargo.toml
    │   ├── generated/         # Generated bindings (cargo nano-ros generate)
    │   └── .cargo/config.toml # Patches for generated crates
    ├── native-listener/
    ├── native-service-server/ # Service example with example_interfaces
    └── native-service-client/
```

**Note**: Message types are generated per-project using `cargo nano-ros generate` rather than
bundled in a `nano-ros-types` crate. This allows each project to generate only the types it
needs and supports any ROS interface package available in the ament index.

## Zenoh-Pico Bindings

Two crates provide Rust bindings for zenoh-pico:

### zenoh-pico-sys (FFI Layer)
Low-level unsafe bindings generated by bindgen:
- Compiles zenoh-pico C library via CMake
- Generates Rust FFI bindings automatically
- Links statically (`links = "zenohpico"`)
- No `std` required

### zenoh-pico (Safe Wrapper)
Idiomatic Rust API wrapping zenoh-pico-sys:

```rust
use zenoh_pico::{Config, Session, KeyExpr};

// Open a session
let config = Config::client("tcp/127.0.0.1:7447")?;
let session = Session::open(config)?;

// Publish
let keyexpr = KeyExpr::new("demo/topic")?;
let publisher = session.declare_publisher(&keyexpr)?;
publisher.put(b"Hello")?;

// Subscribe
let subscriber = session.declare_subscriber(&keyexpr, |sample| {
    println!("Received: {:?}", sample.payload);
})?;
```

**Key Types:**
- `Config` - Session configuration (client/peer mode, locators)
- `Session` - Connection to zenoh network (manages read/lease tasks)
- `KeyExpr` - Topic path with wildcard support
- `Publisher` - Sends data to a key expression
- `Subscriber<F>` - Receives data via callback
- `Sample` - Received message with payload

**Design Notes:**
- `#![no_std]` compatible (requires `alloc` for `Subscriber`)
- Session/Publisher/Subscriber are `Send` but not `Sync`
- Background read/lease tasks started automatically on session open
- RAII: resources cleaned up on drop

**Requirements:**
- Some tests require a running `zenohd` router on `tcp/127.0.0.1:7447`
- Same-session pub/sub requires `Z_FEATURE_LOCAL_SUBSCRIBER=1` (enabled in build)

**Fixed Issues:**
- **KeyExpr dangling pointer bug** - `z_view_keyexpr_t` stores a pointer to the string buffer. When the `KeyExpr` struct was moved (e.g., returned from function), the buffer moved but the pointer didn't update, causing zenoh-pico to read garbage. Fixed by using owned keyexpr (`z_owned_keyexpr_t`) which copies the data.
- Double-free SIGSEGV in subscriber error handling path
- Double-free SIGSEGV when storing context in both Rust struct and closure

### Zephyr C Shim Pattern

For Zephyr integration, direct Rust FFI to zenoh-pico causes struct size mismatches
(Rust's placeholder types don't match the actual C struct sizes). The solution is a
thin C shim layer that handles zenoh-pico types internally:

```c
// examples/zephyr-talker-rs/src/zenoh_shim.c
static z_owned_session_t g_session;
static z_owned_publisher_t g_publisher;

int zenoh_init_config(const char *locator);
int zenoh_open_session(void);
int zenoh_declare_publisher(const char *keyexpr);
int zenoh_publish(const uint8_t *data, size_t len);
void zenoh_close(void);
```

Rust code calls these simple C functions:
```rust
extern "C" {
    fn zenoh_init_config(locator: *const c_char) -> i32;
    fn zenoh_open_session() -> i32;
    fn zenoh_publish(data: *const u8, len: usize) -> i32;
}
```

This pattern avoids FFI struct layout issues while keeping the Rust code clean.

## Key Design Decisions

### 1. `no_std` Support

All core crates must support `#![no_std]` with optional `std` feature:

```rust
#![no_std]

#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "alloc")]
extern crate alloc;
```

**Feature flags:**
- `std` - Full standard library (desktop/Linux)
- `alloc` - Dynamic allocation only (embedded with heap)
- (default) - No heap, static buffers only

### 2. Type System (Replacing X-Macros)

Use Rust traits + proc macros instead of C X-macros:

```rust
// In nano-ros-core/src/types.rs
pub trait RosMessage: Sized {
    const TYPE_NAME: &'static str;
    const RIHS_HASH: &'static str;

    fn serialize<W: CdrWriter>(&self, writer: &mut W) -> Result<(), SerError>;
    fn deserialize<R: CdrReader>(reader: &mut R) -> Result<Self, DeserError>;
}

// Generated via proc macro
#[derive(RosMessage)]
#[ros(type_name = "std_msgs::msg::dds_::String_")]
pub struct StringMsg {
    pub data: heapless::String<256>,  // no_std compatible
}
```

### 3. Memory Management

**Static buffers for `no_std`:**
```rust
use heapless::{String, Vec};

pub struct Publisher<const BUF_SIZE: usize> {
    buffer: [u8; BUF_SIZE],
    // ...
}
```

**Dynamic allocation with `alloc` feature:**
```rust
#[cfg(feature = "alloc")]
use alloc::{string::String, vec::Vec};
```

### 4. Async Support

Design for async but don't require it:

```rust
// Blocking API (always available)
pub fn publish<M: RosMessage>(&mut self, msg: &M) -> Result<(), Error>;

// Async API (with feature flag)
#[cfg(feature = "async")]
pub async fn publish_async<M: RosMessage>(&mut self, msg: &M) -> Result<(), Error>;
```

### 5. Transport Abstraction

Abstract over zenoh-pico for portability:

```rust
pub trait Transport {
    type Publisher: TransportPublisher;
    type Subscriber: TransportSubscriber;
    type Error;

    fn create_publisher(&mut self, topic: &TopicInfo) -> Result<Self::Publisher, Self::Error>;
    fn create_subscriber<F>(&mut self, topic: &TopicInfo, callback: F) -> Result<Self::Subscriber, Self::Error>
    where F: FnMut(&[u8]) + Send;
}
```

## Original Pico-ROS Key Structures

### Node
```c
typedef struct {
    char* name;
    uint32_t domain_id;
    char guid[17];
    z_owned_session_t* session;
    zc_owned_liveliness_token_t node_token;
} picoros_node_t;
```

### Publisher
```c
typedef struct {
    z_owned_publisher_t publisher;
    char* topic_name;
    char* topic_type;
    char* rihs_hash;
    rmw_attachment_t attachment;
    z_publisher_put_options_t options;
    zc_owned_liveliness_token_t pub_token;
} picoros_publisher_t;
```

### Subscriber
```c
typedef struct {
    z_owned_subscriber_t subscriber;
    char* topic_name;
    char* topic_type;
    char* rihs_hash;
    picoros_sub_cb_t callback;
    void* userdata;
    zc_owned_liveliness_token_t sub_token;
} picoros_subscriber_t;
```

### RMW Attachment (for rmw_zenoh compatibility)
```c
typedef struct __attribute__((__packed__)) {
    int64_t sequence_number;
    int64_t time;
    uint8_t rmw_gid_size;
    uint8_t rmw_gid[16];
} rmw_attachment_t;
```

## CDR Serialization Format

- 4-byte header: `0x00 0x01 0x00 0x00` (little-endian CDR)
- Alignment: primitives aligned to their size
- Strings: 4-byte length prefix + data + null terminator
- Sequences: 4-byte count + elements

## Topic Naming Convention (rmw_zenoh compatible)

**Data key expression format (for ROS 2 Humble):**
```
<domain_id>/<topic_name>/<message_type>/<type_hash>
```

Example:
```
0/chatter/std_msgs::msg::dds_::Int32_/TypeHashNotSupported
```

**Note:** For Humble, use `TypeHashNotSupported` as the type hash (no `RIHS01_` prefix).
Newer ROS 2 versions (Iron+) use `RIHS01_<sha256>` format.

## Service Naming Convention

```
<domain_id>/<service_name>/<service_type>_/RIHS01_<hash>
```

## Liveliness Token Format

**Node:**
```
@ros2_lv/<domain_id>/<zid>/0/0/NN/%/%/<node_name>
```

**Publisher:**
```
@ros2_lv/<domain_id>/<zid>/0/11/MP/%/%/<node_name>/%<topic>/<type>/RIHS01_<hash>/<qos>
```

**Subscriber:**
```
@ros2_lv/<domain_id>/<zid>/0/11/MS/%/%/<node_name>/%<topic>/<type>/RIHS01_<hash>/<qos>
```

Key points:
- ZenohId must be LSB-first hex format
- Topic names use `%` prefix (e.g., `%chatter`)
- Liveliness tokens **do** use `RIHS01_` prefix (unlike data keyexprs)
- QoS format: `reliability:durability:history,depth:...` (e.g., `2:2:1,1:,:,:,,` for BEST_EFFORT)

## Build Commands

Use `just` for common tasks (default recipes use `no_std`):

```bash
just setup          # Install toolchains and tools
just build          # Build with no_std (default)
just build-embedded # Build for thumbv7em-none-eabihf
just check          # Format + clippy with no_std
just test           # Run tests (requires std)
just test-miri      # Run Miri for undefined behavior detection
just test-all       # Run test + test-miri
just format         # Format code (nightly)
just quality        # Run check + test
just doc            # Generate and open docs
just clean          # Clean build artifacts

# Embedded examples (STM32F4)
just build-embedded-examples  # Build RTIC, Embassy, polling examples
just check-embedded-examples  # Check without full build
just size-embedded-examples   # Show binary sizes

# Real-time static analysis
just check-realtime    # Clippy with RT safety lints
just check-miri        # Miri UB detection
just analyze-stack     # Stack usage analysis (nightly)
just static-analysis   # Run all static analysis

# zenoh-pico specific
cargo test -p zenoh-pico  # Run zenoh-pico tests (no router needed for most)
```

**Toolchain**: `rust-toolchain.toml` configures stable + `thumbv7em-none-eabihf` target.

## Target Platform Notes

### Zephyr RTOS
- Use `zenoh-pico` Zephyr port
- Configure via Kconfig/devicetree
- Consider `embassy` for async

### NuttX RTOS
- POSIX-like interface simplifies porting
- Can use `std` with NuttX's libc
- `zenoh-pico` has NuttX support

## RTIC and Embedded Support

nano-ros supports RTIC (Real-Time Interrupt-driven Concurrency) and other embedded
real-time frameworks through the `rtic` feature flag.

### Feature Flags

```toml
# For RTIC/Embassy applications
[dependencies]
nano-ros-node = { path = "...", default-features = false, features = ["rtic"] }
nano-ros-transport = { path = "...", default-features = false, features = ["rtic", "sync-critical-section"] }
```

### Static Buffer Allocation

The `rtic` feature enables static buffer allocation via const generics:

```rust
use nano_ros_node::{ConnectedNode, ConnectedSubscriber, DEFAULT_MAX_TOKENS};

// Node with custom token limit
let node: ConnectedNode<8> = ...;

// Subscriber with custom buffer size
let subscriber: ConnectedSubscriber<MyMsg, 512> =
    node.create_subscriber_sized("/topic")?;

// Service with custom request/reply buffers
let server: ConnectedServiceServer<MyService, 256, 256> =
    node.create_service_sized("/service")?;
```

### Default Buffer Sizes

| Constant | Default | Purpose |
|----------|---------|---------|
| `DEFAULT_MAX_TOKENS` | 16 | Max liveliness tokens (publishers + subscribers) |
| `DEFAULT_RX_BUFFER_SIZE` | 1024 | Subscriber receive buffer |
| `DEFAULT_REQ_BUFFER_SIZE` | 1024 | Service request buffer |
| `DEFAULT_REPLY_BUFFER_SIZE` | 1024 | Service reply buffer |

### Timing Constants

For manual polling (without background threads):

```rust
use nano_ros_node::rtic::{POLL_INTERVAL_MS, KEEPALIVE_INTERVAL_MS};

// POLL_INTERVAL_MS = 10ms - How often to poll for incoming messages
// KEEPALIVE_INTERVAL_MS = 1000ms - How often to send keepalive
```

### Example Patterns

**RTIC Example** (`examples/rtic-stm32f4/`):
```rust
#[task(priority = 2)]
async fn zenoh_poll(_cx: zenoh_poll::Context) {
    loop {
        // Poll for incoming messages
        Mono::delay(POLL_INTERVAL_MS.millis()).await;
    }
}

#[task(priority = 1)]
async fn zenoh_keepalive(_cx: zenoh_keepalive::Context) {
    loop {
        // Send keepalive
        Mono::delay(KEEPALIVE_INTERVAL_MS.millis()).await;
    }
}
```

**Embassy Example** (`examples/embassy-stm32f4/`):
```rust
#[embassy_executor::task]
async fn zenoh_poll_task() {
    loop {
        Timer::after(Duration::from_millis(POLL_INTERVAL_MS as u64)).await;
    }
}
```

**Polling Example** (`examples/polling-stm32f4/`):
```rust
// Simple main loop without executor
loop {
    if poll_timer.elapsed_ms(POLL_INTERVAL_MS) {
        // Poll zenoh
    }
    if keepalive_timer.elapsed_ms(KEEPALIVE_INTERVAL_MS) {
        // Send keepalive
    }
}
```

### Memory Requirements

See `docs/memory-requirements.md` for detailed memory calculations.

### WCET Analysis

See `docs/wcet-analysis.md` for Worst-Case Execution Time analysis workflow including:
- RTIC-Scope integration for hardware tracing
- DWT cycle counter measurement
- Task-specific WCET characteristics

### Schedulability Analysis

See `docs/schedulability-analysis.md` for Rate-Monotonic Analysis (RMA) and response time analysis:
- Utilization bound tests
- Response time calculation with worked examples
- Priority Ceiling Protocol blocking analysis
- Python script for automated analysis

### Real-Time Static Analysis

See `docs/realtime-lint-guide.md` for detecting anti-patterns that violate real-time guarantees:

| Anti-Pattern | Detection Method |
|--------------|------------------|
| Unbounded loops | Clippy: `infinite_iter`, `while_immutable_condition` |
| Recursion | Clippy: `unconditional_recursion` + cargo-call-stack |
| Large stack arrays | Clippy: `large_stack_arrays` |
| Heap allocation | `no_std` + `heapless` crate |
| Missing timeouts | Custom Dylint lints |

**Quick check:**
```bash
just check-realtime     # Clippy with RT safety lints
just static-analysis    # Full analysis suite (includes Miri)
```

### Zenoh-Pico Heap Requirements

**Important:** Zenoh-pico requires heap allocation via `z_malloc`/`z_free` for:
- Session creation and management
- Publishers and subscribers (state objects)
- I/O buffers for network packets
- Message samples and internal collections

This means:
- The Rust `zenoh` feature implies `alloc`
- Pure `no_std` without allocator cannot use zenoh directly
- Embedded systems need RTOS heap support (FreeRTOS, Zephyr)

**Recommended pattern for embedded:** Use the C shim approach (see `examples/zephyr-talker-rs/`).
The C shim manages zenoh-pico's heap allocations while keeping Rust code simple.

### Embedded Integration Guide

See `docs/embedded-integration.md` for comprehensive embedded integration documentation including:
- C shim pattern for Zephyr/FreeRTOS
- RTIC, Embassy, and polling examples
- Memory budgeting
- Hardware requirements

### Build Verification

```bash
# Verify no-alloc build compiles
just check-no-alloc
```

This checks that the RTIC features work without heap allocation.

## Error Handling

Use `Result<T, E>` throughout:

```rust
#[derive(Debug)]
pub enum Error {
    Serialization(SerError),
    Transport(TransportError),
    Timeout,
    InvalidMessage,
    BufferTooSmall,
}
```

## Testing Strategy

- Unit tests with `#[cfg(test)]` (requires `std`)
- Miri tests for undefined behavior detection
- CDR format compatibility tests against Micro-CDR
- QEMU tests for Cortex-M targets (Phase 2)
- Integration tests against real zenoh router
- Multi-node QEMU testing (Zephyr + native)
- Consider `defmt` for embedded debugging

## Development Practices

### System Package Installation

**Never install system packages directly.** When a system package is needed:
1. Stop and inform the user what package is required
2. Provide the exact installation command for them to run
3. Continue after user confirms installation

Example:
```
QEMU ARM emulator is required but not installed.
Please run: sudo apt install qemu-system-arm
```

This ensures the user maintains control over their system and is aware of all dependencies being installed.

### Privileged Commands (sudo)

**Never execute sudo commands directly.** When root privileges are needed:
1. Explain what needs to be done and why it requires root
2. Provide the exact command(s) for the user to run
3. Wait for user confirmation before continuing

Example:
```
TAP interface setup requires root privileges.
Please run: sudo ./scripts/setup-zephyr-network.sh

This creates a TAP device owned by your user, allowing
Zephyr to run without sudo afterward.
```

This ensures users maintain control over privileged operations.

### Quality Checks

**Always run `just quality` after completing a task.** This runs:
1. Format check (`cargo +nightly fmt --check`)
2. Clippy with no default features (`-D warnings`)
3. All tests via nextest

Fix any issues before considering a task complete.

### Handling Unused Variable Warnings

When encountering unused variable warnings, follow this practice:

1. **Rename to `_name`** to suppress the warning
2. **Always add a comment** explaining why the variable is unused
3. **Use `#[allow(dead_code)]`** for struct fields in test code that exist for structural completeness

**Common patterns:**

```rust
// Trait method signature requires parameter, but implementation doesn't use it
fn serialize(&self, _writer: &mut CdrWriter) -> Result<(), SerError> {
    // Empty message - no fields to serialize
    Ok(())
}

// Test mock with fields for structural completeness
#[derive(Debug, Clone)]
struct MockRequest {
    // Fields exist for structural completeness but are not read
    // since the mock serialize/deserialize implementations are no-ops
    #[allow(dead_code)]
    pub a: i32,
    #[allow(dead_code)]
    pub b: i32,
}
```

**When to use TODO comments:**

If the unused variable represents incomplete functionality or future work, add a TODO:

```rust
fn process(&self, _data: &[u8]) -> Result<()> {
    // TODO: Implement data processing when the protocol layer is complete
    Ok(())
}
```

## Documentation

Development documentation lives in `docs/`:

```
docs/
├── rmw_zenoh_interop.md           # ROS 2 rmw_zenoh protocol documentation
├── embedded-integration.md        # Embedded integration guide (RTIC, Embassy, Zephyr)
├── wcet-analysis.md               # WCET measurement and analysis workflow
├── schedulability-analysis.md     # RMA and response time analysis
├── realtime-lint-guide.md         # Static analysis for RT anti-patterns
├── memory-requirements.md         # Memory budgeting for embedded
├── roadmap/                       # Development phases and milestones
│   ├── phase-1-foundation.md      # CDR, types, macros (COMPLETE)
│   ├── phase-2-zephyr-qemu.md     # Zephyr, QEMU, transport (COMPLETE)
│   └── phase-3-services-params.md # Services, parameters, hardware (PLANNING)
├── architecture/                  # Design documents and ADRs
└── api/                           # API documentation (if not rustdoc)
```

## Development Phases

| Phase | Focus | Status |
|-------|-------|--------|
| Phase 1 | CDR serialization, types, proc macros | **Complete** |
| Phase 2A | ROS 2 Interoperability (native) | **Complete** |
| Phase 2B | Zephyr integration + QEMU testing | **Complete** |
| Phase 3 | Services, parameters, unified API | **In Progress** |
| Phase 4 | Message generation (cargo nano-ros) | **Complete** |
| Phase 5 | RTIC integration | **Complete** |
| Phase 6 | ROS 2 Actions | **Planning** |

See `docs/roadmap/` for detailed work items.

**Deployment Model:**
- ROS 2 nodes run on Linux host using `rmw_zenoh_cpp`
- nano-ros nodes run on Zephyr RTOS (embedded targets)
- Communication via zenoh router on host

### Phase 2A Progress (ROS 2 Interoperability) - COMPLETE
- [x] `zenoh-pico-sys` - FFI bindings with static linking
- [x] `zenoh-pico` - Safe wrapper (Config, Session, Publisher, Subscriber, Liveliness)
- [x] `nano-ros-transport` - ZenohTransport backend with RMW Attachment support
- [x] `nano-ros-node` - ConnectedNode with transport integration
- [x] RMW Attachment support - Required metadata for rmw_zenoh compatibility
- [x] Liveliness tokens - Node/publisher/subscriber discovery
- [x] Native examples updated - talker/listener use real zenoh transport
- [x] nano-ros ↔ nano-ros communication tested and working
- [x] ROS 2 → nano-ros communication working (via wildcard subscriber)
- [x] nano-ros → ROS 2 communication working (Humble)

### Phase 2B Progress (Zephyr Integration) - COMPLETE
- [x] All core crates no_std compatible
- [x] West manifest workflow (`west.yml`, `zephyr/module.yml`)
- [x] Zephyr workspace setup script (`zephyr/setup.sh`)
- [x] zenoh-pico added to west manifest (v1.5.1)
- [x] Zephyr talker with zenoh-pico transport (`examples/zephyr-talker-rs/`)
- [x] Zephyr listener with zenoh-pico transport (`examples/zephyr-listener-rs/`)
- [x] C shim for zenoh-pico FFI (avoids struct size issues)
- [x] Network setup script (`scripts/setup-zephyr-network.sh`)
- [x] End-to-end test: Zephyr native_sim → zenoh router → native subscriber
- [ ] Hardware validation (deferred to Phase 3)

### Phase 3 Progress (Services, Parameters, Unified API, Hardware) - IN PROGRESS

**3.1 ROS 2 Services - Infrastructure Complete:**
- [x] Service traits (`RosService` with Request/Response types)
- [x] zenoh-pico queryable support (for service servers)
- [x] Transport layer service client/server (`ServiceInfo`, transport traits)
- [x] Node API: `create_service()`, `create_client()` (in ConnectedNode)
- [ ] `#[derive(RosService)]` proc macro
- [ ] Service examples and ROS 2 interop tests
- [ ] `rcl_interfaces` service types for parameters

**3.2 ROS 2 Parameters - Core Complete:**
- [x] Complete `nano-ros-params` implementation
- [x] Parameter types (`ParameterValue`, `ParameterType`, `ParameterDescriptor`)
- [x] Parameter server with static storage (`ParameterServer`, MAX_PARAMETERS=32)
- [x] Constraint validation (read-only, type checking, range constraints)
- [x] Fluent API via `ParameterBuilder`
- [ ] `rcl_interfaces` message/service types
- [ ] Parameter service handlers (`~/get_parameters`, `~/set_parameters`, etc.)
- [ ] ROS 2 CLI interop (`ros2 param list/get/set`)

**3.3 Unified `nano-ros` Crate - Complete:**
- [x] Create `crates/nano-ros/` as main entry point
- [x] Re-export all sub-crate types (`nano_ros::prelude::*`)
- [x] Feature flags: `std`, `alloc`, `zenoh`
- [x] `no_std` compatible
- [x] Parameter types integrated
- [x] Service types integrated
- [ ] Update all examples to use unified API

**3.4 Hardware Validation:**
- [ ] NUCLEO-F429ZI (STM32F429, Ethernet)
- [ ] Performance benchmarks (latency, throughput, memory)
- [ ] Reliability testing

**Next Steps:** Service examples, update examples to unified API, hardware validation.

### Phase 4 Progress (Message Generation) - COMPLETE

The `cargo nano-ros generate` command is now available for generating `no_std` compatible
message bindings from ROS 2 interface packages.

**Implementation**:
- [x] `rosidl-parser` - Parse .msg, .srv, .action files
- [x] `rosidl-codegen` - Code generation with Askama templates
- [x] `rosidl-bindgen` - Binding generator library
- [x] `cargo-nano-ros` - Standalone cargo subcommand
- [x] Dependency resolution via ament index
- [x] `.cargo/config.toml` generation with patches
- [x] `no_std` compatible output using `heapless` types
- [x] Native examples updated to use generated bindings

**Usage**:
```bash
cargo nano-ros generate                    # Generate from package.xml
cargo nano-ros generate --force            # Regenerate existing
cargo nano-ros generate --output bindings  # Custom output directory
```

See "Message Binding Generation" section above for detailed documentation.

## Message Binding Generation

nano-ros uses generated Rust bindings for ROS 2 message types. The `cargo nano-ros generate` command generates `no_std` compatible bindings from `package.xml` dependencies.

### Overview

The binding generator lives in `colcon-nano-ros/packages/cargo-nano-ros/` and provides:
- Standalone `cargo nano-ros` subcommand for generating bindings
- Pure Rust, `no_std` compatible output using `heapless` types
- Automatic dependency resolution via ament index
- `.cargo/config.toml` generation for crate patches

### Prerequisites

1. **ROS 2 environment sourced** - Required for ament index access
   ```bash
   source /opt/ros/humble/setup.bash
   ```

2. **package.xml in project root** - Declares ROS interface dependencies
   ```xml
   <?xml version="1.0"?>
   <package format="3">
     <name>my_package</name>
     <version>0.1.0</version>
     <description>My nano-ros package</description>
     <maintainer email="dev@example.com">Developer</maintainer>
     <license>Apache-2.0</license>
     <depend>std_msgs</depend>
     <depend>geometry_msgs</depend>
     <export>
       <build_type>ament_cargo</build_type>
     </export>
   </package>
   ```

3. **cargo-nano-ros installed**
   ```bash
   cd colcon-nano-ros && just install
   # Or: cargo install --path colcon-nano-ros/packages/cargo-nano-ros
   ```

### Workflow

**Step 1: Create package.xml**

Declare your ROS interface dependencies in `<depend>` tags:
```xml
<depend>std_msgs</depend>      <!-- For std_msgs::msg::Int32, String, etc. -->
<depend>example_interfaces</depend>  <!-- For service types -->
```

**Step 2: Generate bindings**

```bash
cd my_project
cargo nano-ros generate
```

This will:
1. Parse `package.xml` to find dependencies
2. Resolve transitive dependencies via ament index
3. Filter to interface packages (those with msg/srv/action)
4. Generate bindings to `generated/` directory
5. Create `.cargo/config.toml` with `[patch.crates-io]` entries

**Step 3: Add dependencies to Cargo.toml**

Reference the generated crates using crates.io version specifiers:
```toml
[dependencies]
std_msgs = { version = "*", default-features = false }
example_interfaces = { version = "*", default-features = false }
```

The `.cargo/config.toml` patches redirect these to local paths.

**Step 4: Use in code**

```rust
use std_msgs::msg::Int32;
use example_interfaces::srv::{AddTwoInts, AddTwoIntsRequest, AddTwoIntsResponse};

let msg = Int32 { data: 42 };
```

### Command Options

```bash
cargo nano-ros generate [OPTIONS]

Options:
  -m, --manifest <PATH>     Path to package.xml [default: package.xml]
  -o, --output <DIR>        Output directory [default: generated]
  -n, --nano-ros <PATH>     Path to nano-ros crates (for config patches)
  -f, --force               Overwrite existing bindings
  -v, --verbose             Enable verbose output
      --no-config           Skip .cargo/config.toml generation
```

### Generated Output Structure

```
my_project/
├── package.xml              # Your dependency declarations
├── Cargo.toml               # Your package manifest
├── src/
│   └── main.rs              # Your code using generated types
├── generated/               # Generated bindings (do not edit)
│   ├── std_msgs/
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs       # #![no_std]
│   │       └── msg/
│   │           ├── mod.rs
│   │           └── int32.rs
│   └── builtin_interfaces/  # Transitive dependency
│       └── ...
└── .cargo/
    └── config.toml          # [patch.crates-io] entries
```

### Generated Code Features

**no_std by default:**
```rust
#![no_std]

pub mod msg;
```

**std feature for optional std support:**
```toml
[features]
default = []
std = ["nano-ros-core/std", "nano-ros-serdes/std"]
```

**heapless types for embedded:**
```rust
pub struct String {
    pub data: heapless::String<256>,
}

pub struct Arrays {
    pub data: heapless::Vec<i32, 64>,
}
```

**Service types with Request/Response:**
```rust
pub struct AddTwoInts;
pub struct AddTwoIntsRequest { pub a: i64, pub b: i64 }
pub struct AddTwoIntsResponse { pub sum: i64 }

impl RosService for AddTwoInts {
    type Request = AddTwoIntsRequest;
    type Reply = AddTwoIntsResponse;
}
```

### Example: Native Examples

The `examples/native-*` directories demonstrate this workflow:

```bash
# Generate bindings for native-talker
cd examples/native-talker
source /opt/ros/humble/setup.bash
cargo nano-ros generate

# Build and run
cargo build
cargo run -- --tcp 127.0.0.1:7447
```

Each example has:
- `package.xml` declaring `std_msgs` or `example_interfaces`
- `Cargo.toml` with message crate dependencies
- Generated bindings in `generated/`
- `.cargo/config.toml` with patches

### Standalone Package Mode

Examples are configured as standalone packages (excluded from workspace) because each has its own `.cargo/config.toml` patches. Building from workspace root would conflict.

```toml
# Root Cargo.toml
[workspace]
exclude = [
    "examples/native-talker",
    "examples/native-listener",
    "examples/native-service-server",
    "examples/native-service-client",
]
```

Build each example from its own directory:
```bash
cd examples/native-talker && cargo build
cd examples/native-service-client && cargo build
```

### Regenerating Bindings

To regenerate after ROS package updates or dependency changes:
```bash
cargo nano-ros generate --force
```

### Troubleshooting

**"Failed to load ament index"**
- Ensure ROS 2 is sourced: `source /opt/ros/humble/setup.bash`

**"Package 'X' not found in ament index"**
- Check package is installed: `ros2 pkg list | grep X`
- Install if missing: `sudo apt install ros-humble-X`

**Build errors with generated code**
- Regenerate with `--force` flag
- Check nano-ros crate compatibility

## ROS 2 rmw_zenoh Interoperability

See `docs/rmw_zenoh_interop.md` for detailed protocol documentation.

### Current Status - WORKING

| Direction | Status | Notes |
|-----------|--------|-------|
| nano-ros ↔ nano-ros | ✅ Working | Full pub/sub communication |
| ROS 2 → nano-ros | ✅ Working | Uses wildcard subscriber to match any type hash |
| nano-ros → ROS 2 | ✅ Working | Tested with ROS 2 Humble + rmw_zenoh_cpp |

### Key Implementation Details

1. **Data keyexpr format**: For Humble, use `TypeHashNotSupported` without `RIHS01_` prefix
2. **Liveliness tokens**: Use `RIHS01_` prefix, `%` for topic names, LSB-first ZenohId
3. **QoS string**: Use explicit values `2:2:1,1:,:,:,,` (BEST_EFFORT/VOLATILE)
4. **RMW Attachment**: 33 bytes (8+8+1+16) using zenoh serializer for compatibility

### Test Commands

```bash
# Terminal 1: Start zenoh router
zenohd --listen tcp/127.0.0.1:7447

# Terminal 2: Run nano-ros talker
cargo run -p native-talker --features zenoh -- --tcp 127.0.0.1:7447

# Terminal 3: Run ROS 2 listener
source /opt/ros/humble/setup.bash
export RMW_IMPLEMENTATION=rmw_zenoh_cpp
export ZENOH_CONFIG_OVERRIDE='mode="client";connect/endpoints=["tcp/127.0.0.1:7447"]'
ros2 topic echo /chatter std_msgs/msg/Int32 --qos-reliability best_effort
```

Test scripts available:
- `scripts/test-qos.sh` - Test nano-ros → ROS 2 communication
- `scripts/test-pubsub.sh` - Test nano-ros ↔ nano-ros (requires zenohd)
- `scripts/test-pubsub-peer.sh` - Test peer mode (no router)

### Zephyr E2E Test (native_sim)

```bash
# One-time setup: Create TAP interface for Zephyr networking
sudo ./scripts/setup-zephyr-network.sh

# Terminal 1: Start zenoh router
zenohd --listen tcp/0.0.0.0:7447

# Terminal 2: Run native subscriber
cargo run -p zenoh-pico --example sub_test --features std

# Terminal 3: Build and run Zephyr talker (from zephyr workspace)
cd ~/nano-ros-workspace
west build -b native_sim/native/64 nano-ros/examples/zephyr-talker-rs
./build/zephyr/zephyr.exe
```

The Zephyr talker connects to the host at 192.0.2.2:7447 and publishes
Int32 messages to `demo/chatter`. The native subscriber receives and
decodes the messages.

## References

- Original Pico-ROS: `external/Pico-ROS-software/`
- zenoh-pico: `external/Pico-ROS-software/thirdparty/zenoh-pico/`
- Micro-CDR: `external/Pico-ROS-software/thirdparty/Micro-CDR/`
- ROS 2 CDR spec: OMG DDS-XTypes
- rmw_zenoh: https://github.com/ros2/rmw_zenoh
- Zephyr Rust: https://github.com/zephyrproject-rtos/zephyr-lang-rust
- Embassy: https://embassy.dev/
- Ferrocene (deferred): https://ferrocene.dev/
